<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>不再见，2025</title>
    <link href="/posts/Farewell-2025/"/>
    <url>/posts/Farewell-2025/</url>
    
    <content type="html"><![CDATA[<p>做个简单的回顾吧。</p><span id="more"></span><p>这一年来都没写什么东西，眼看一年要结束了，感觉写点什么，心里会踏实一些，尽管都是些没营养的内容。</p><p>不仅是博客没更新，今年就连朋友圈都没怎么发，也许是因为这一年来每一天的生活几乎都差不多，没什么可记录的吧；又或许是因为年纪大了，没那么强的分享欲了；不过我觉得更合理的解释应该是现在已经不像在大学时那样无忧无虑了，没那么多精力去诉说一些可有可无的事情……无论怎样，有一点倒是值得明确：那就是不开心的事情就别记录了，让它随着时间逐渐被淡忘就好了。要是写了下来，以后翻看到，不好的回忆不就又浮现了吗？当然了，倒也不排除通过记录来进行倾诉，毕竟没人愿意倾听哥布林说什么，只能自己写给自己看了。</p><p>原本是想在 2025 年的最后一个周末写的，想说晚上写一写，写困了就睡觉，无奈自制力还是太差了。不过也无所谓了，最后一天写又怎么样呢，反正又不是什么正式文件，也不是给什么领导看的，就想到哪写到哪吧。</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>已经在医院混了快一年半了，真舒服啊，有多舒服？</p><ol><li>每天上班时间只有 7 小时。</li><li>每天准时下班（上下班不用打卡）。</li><li>每周能双休。</li><li>节假日不打折不阉割，该放多少天就放多少天。</li><li>虽然时不时要值班，但是也有值班费，并且如果是周末值班还会有相应天数的带薪调休。</li><li>得益于目前所在的工作组、科室分工、单位现状，每天上班的工作强度不算高。我甚至还有时间炒股和学点其它的知识。</li><li>办公室小伙伴都聊得来，每天有说有笑（虽然领导很傻逼）。</li><li>办公环境和条件都很不错。</li><li>离家车程 1 小时，回家成本低。</li><li>外表光鲜亮丽，别人打听你做什么工作的，你说「我在医院」，就给你装到了。</li><li>基于工作内容和服务的对象，你有理由在没事干的时候去住院部找护士小姐姐聊天，把每一层楼都走一遍，看哪个顺眼就找哪个聊，没关系。</li></ol><p>不过舒服也有代价，而且很致命：</p><ol><li>岗位为第三方派遣，待遇和福利都不如医院的正式员工。并且第三方转正的概率极低。</li><li>单位由内到外由上到下的工作氛围和工作态度都非常烂，烂得彻头彻尾。不知道是只有这个单位是这样还是所有事业单位都是这样，具体表现就是大家都不想担责且分工极其明确，不是该我干的活，就算我能干，我也绝对不会干。</li><li>科室没有什么大神，领导也都是三脚猫功夫，没有什么技术积累和沉淀，简单来说就是「能学的不多，学到了也没什么用」。</li></ol><p>那好，假设现在给一次选择的机会，A 是继续留在广州干最难受最累最憋屈但是按照领导画的饼来说是很有前途和钱途的销售；B 是在这里躺平。请选择：</p><blockquote><p>那肯定他妈选 B 啊，至少目前是这样。不是，兄弟，我他妈就一哥布林，我也想通了，这么多年了，很多东西是难以改变的……人活着最重要的就是他妈的开心，为什么要去折磨自己？躺在舒适区不好吗？说不定过两年我他妈得癌症死了呢？</p><p>你可以说这是懦弱的表现，我无所谓，毕竟同一件事情站在 100 个角度就有 100 种评价，你可以认同也可以批判。别说外人了，我他妈我自己都经常会有左右脑互搏自己反驳自己的情况……但是，如果自己想这么做的话，又有什么要在意别人看法的必要呢？</p></blockquote><p>说好不谈论不开心的事情的，到此为止吧。我倒也不是那种会放任自己虚度光阴的人，我还是会给自己找点事情做。我只是自制力比较差，又有点懒罢了。希望新的一年，无论是我，还是这个单位，运气都能好一点吧。不过话又说回来，基于我入职至今的经历，我其实是挺想看这个单位毁灭的，我想看这些领导的笑话。倒不是因为见不得单位好（毕竟也是自己所在的单位），而是因为前面也说了，这些人的工作态度都有问题。对我个人而言，反正也不能转正，给多少钱就干多少活，吃瓜就是我在这个单位坚持下去的目的。</p><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><h3 id="考证"><a href="#考证" class="headerlink" title="考证"></a>考证</h3><p>今年上半年考高项没过，第一批论文考绩效域，因为时间不够压根就没准备到绩效域的论文。下半年以为医院要开展电子病历评级的准备工作，怕没时间复习，就没报名高级，只报了个初级，还好过了。初级是转正的硬性指标，虽然前面说了第三方大概率无法转正，但是既然不打算考高级了那就先拿下个初级以防万一吧。</p><p>既然提到电子病历了那就多说一嘴。整个下半年一直到 12 月末尾，主任才开始召集我们来准备评级的材料……在这之前医务科发了通知，其中提到材料的提交截止日期是二六年的 1 月 9 日。要知道在二四年的时候，准备电子病历材料可是花费了我们科室所有人将近两个月的时间，二五年却只给了半个月的时间来准备，这如何能完成得了？就算真的赶工完成了，质量又怎么得到保证？所以这也验证了我前面所说的，不知道这些领导都在想什么。</p><h3 id="炒股"><a href="#炒股" class="headerlink" title="炒股"></a>炒股</h3><p>炒股票属于赌博，我姑且也把它划入学习的范围（你就说学习博弈算不算学习吧）。</p><p>在我的认知中，炒股的学习成本、资金成本、风险收益相较于斗地主和麻将这些以往我接触的赌博活动来说都要高得多。所以我原本以为我这辈子都不会接触股票，直到老爸和姑丈叫我玩一玩，然后爷爷这边也给了 5 万块钱本金以后，我才在 10 月份开户了。这期间姑丈说的一些话让我印象还挺深，原话是什么我忘了，大概意思就是「男人这辈子多少都要赌一点，像他自己就是无论什么赌局基本都会参与一下」。其实这些话也没什么深度，只是让我加深了那种「人来到这世上，有些事情要是有条件，倒也还是可以体验一下，经历一下」的感觉。</p><h2 id="娱乐"><a href="#娱乐" class="headerlink" title="娱乐"></a>娱乐</h2><h3 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h3><p>今年玩了两部 3A 大作，分别是《巫师3：狂猎》和《黑神话：悟空》。前者主线 + 两个 DLC 总共玩了 175.9 个小时（算它 170 个小时吧，因为要去除掉挂机和其它一些无意义的时间浪费）；后者则是一周目花了六十多个小时。两者都是非常优秀的大作名作，有小毛病，但是瑕不掩瑜。对于这样的佳作，我也没必要再去 review 了，网上应该有很多测评已经把我想说的都替我说了，剩下一些可有可无无关痛痒的观点和意见也懒得再记录了。总结来说就是：对于电子游戏玩家来说，这两部作品就是人生中应该要去踏上的旅程，毫不夸张。</p><p>手游这边，我想想，我也不记得是今年还是去年弃坑赛马娘的了。倒是今年又重新捡起《棕色尘埃2》了（虽然也记不清是几月份回归的了），我觉得这游戏相比国产二游来说还挺良心的，不肝不氪。举例来说，在地图上可以自动寻路、日常狗粮副本可以「一键出征」，这些便利都可以减少重复操作导致的无聊和时间浪费。其次是抽卡爆率是真的高，福利也很不错，基本不用担心没有钻石抽卡。即使抛开不肝不氪来说，国外运营的手游在监管这一块就是要比国内有优势。即使女性角色着装暴露，玩家也不用每天提心吊胆害怕游戏被举报、卡面立绘被和谐之类的事情。</p><h3 id="影视"><a href="#影视" class="headerlink" title="影视"></a>影视</h3><p>想罗列一下今年看了什么影视作品，发现除了 bangumi 帮我记录日漫的观看进度以外，其它的例如电影或者特摄，我自己也想不起来我看过什么了……罢了，那便只记录一下看过的番吧：</p><ul><li>辉夜大小姐想让我告白～天才们的恋爱头脑战～</li><li>炎炎消防队</li><li>工作细胞</li><li>剧场版 OVERLORD 圣王国篇</li><li>盾之勇者成名录</li><li>明日方舟：黎明前奏</li></ul><p>今年看的番除了工作细胞和骨王以外，都让我觉得挺无聊的，可能也是因为年纪大了吧，要是十年前的我，说不定还能看得津津有味。</p><p>其中不得不提的就是炎炎消防队和盾之勇者成名录这两坨大的，前者我已经单独写一篇吐槽记录出来了；后者原本我也写了草稿记录感想，但是后面懒得整理了，就这样吧，一坨屎而已，没必要花太多精力在这上面。总结来说，今年的我也是找屎吃的高手。</p><h3 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h3><p>今年一整年主要是在 Apple Music 上听的歌，看了 Apple Music 的年度回顾，发现自己今年听得比较多的是 J-Pop（City-Pop）。这很合理，毕竟我就是为了听这些日语歌曲才去订阅日区的 Apple Music 的。其中 City-Pop 可以说是深得我心，这类风格的音乐几乎适用于任何场景，你可以在淋浴时播放它们，也可以在开车时播放它们。即使你在车上与他人聊天，只需要稍微调低音量，City-Pop 就可以充当不错的背景音乐，在你们结束一个话题时，毫无违和感地插入进来。</p><p><em>THE ALFEE</em> 的《星空のディスタンス》我从年初听到现在，真是百听不厌啊。相同的专辑里还有一首《メリーアン》也很不错。另一张专辑里的《サファイアの瞳》也在 9 月份的时候被我加进播放列表了。</p><p>J-Pop 之后就是英文歌曲了。<em>LINKIN PARK</em> 在我心中的地位依旧无人能够撼动，去年回归发行的《From Zero》在后来迎来了 Deluxe Edition ，新增的 3 首歌曲也挺符合我的胃口。除此以外，今年新加入播放列表的英文歌曲的来源都零零散散，并不是来自特定的某位歌手或专辑，有些是在网上听到的，有些则是 Apple Music 算法推荐的，所以这里也不再记录了。</p><p>还值得一提的就是游戏的原声音乐。今年玩的两部 3A 大作的原声音乐辑也可谓是顶中顶、神中神。其中黑猴的音乐辑，就连油管千万粉丝博主「耶稣哥」都赞叹不已，他表示上一个让他如此喜爱的原声音乐是游戏《尼尔：机械纪元》的原声音乐。</p><h2 id="购物"><a href="#购物" class="headerlink" title="购物"></a>购物</h2><p>只有在提到「好物」时能立刻让你想起来的东西才能算真正的好物，这些产品往往物有所值甚至物超所值，并且在使用时能给你带来幸福感。</p><p>在这一部分我决定把今年买到的好物都单独设置一个标题进行介绍，需要避雷的垃圾则统一放到一个标题里进行介绍。</p><h3 id="西昊-D03-升降桌"><a href="#西昊-D03-升降桌" class="headerlink" title="西昊 D03 升降桌"></a>西昊 D03 升降桌</h3><p>今年以来一直想要一个升降桌，调查了一下，发现乐歌的名声还挺响亮，遂前往淘宝店铺一看。找了一个价格能接受、性能能满足需求的型号，不过最后也没下单。因为经过进一步了解，得知包括这个型号在内的多个型号似乎在安装时都需要额外打孔（不知道设计师是怎么想的），这就导致我不得不让师傅上门帮忙安装了，但是我又不想外人进我屋子，所以最终还是决定不买了。</p><p>随后我还去看了西昊的桌子，这是因为我在 24 年初买了西昊的椅子，虽然有点贵，但是还挺值。尽管半年后坐垫坏了，但是因为在保修期内，客服马上给我发新的了，换上后就一直用到现在，每天都在用。所以西昊本身有给我留下一定的好印象，加上他们家的桌子不需要额外开孔，价格和性能与之前在乐歌那看中的那个型号相比也差不多，于是就下单了。</p><p>到货以后印象中好像折腾了快两个小时才装好，618 下的单，装好以后就一直用到现在，感觉还挺值。</p><h3 id="拯救者-Y27qf-30-显示器"><a href="#拯救者-Y27qf-30-显示器" class="headerlink" title="拯救者 Y27qf-30 显示器"></a>拯救者 Y27qf-30 显示器</h3><p>现在回过头来看当时买这台显示器属于是冲动消费了，但是产品本身是好产品，国补后 1520 就拿下了，加上品牌溢价，这个性价比还算可以。</p><p>买回来使用了一段时间更加坚定了我的一些想法：</p><ul><li>27 寸或以上的显示器的分辨率至少要是 2K ，或者说最好就是 2K ，因为 1080P 太糊，4K 又要设置缩放。</li><li>1080P 能接受的最大屏幕尺寸就是常见的 24 寸显示器。正常坐姿办公，和显示器保持适当距离的情况下，基本看不到像素点和字体发虚。并且 1080P 分辨率也不需要缩放，字体大小也适中，阅读起来没那么费劲。</li><li>屏幕只有十五六寸的游戏笔记本电脑没必要上 2K 屏。耗电是其一，其二是打游戏时，高分辨率意味着更吃显卡，但是笔记本显卡性能和散热能力本身就不比台式机。只是厂家为了提升产品竞争力，别人家上了 2K 屏，自己又不得不上。有些用户买到手以后还要自行设置回 1080P ，但是这样的话这个 2K 屏的钱不就白花了吗？最好的反面案例就是当年的索尼手机上高分辨率，最好的正面案例就是 Switch ，屏幕小就 720P ，屏幕大就 1080P 。</li><li>当今的媒体资源及对应的网络条件和存储条件还是以 1080P 为主。我的意思是如果你的屏幕分辨率升级到了 2K ，那么你平时观看的影视作品的规格就也要相应地提升才好。然而视频文件体积大了，下载就要求更多的流量，存储就要求更多的空间……所以综合考虑下来真的还是 1080P 的屏幕最实用和实惠。</li></ul><p>我本身就有一台 24 寸 1080P 的显示器，如果给我再选一次，我就不会买这台拯救者显示器了。如果真的需要多一个屏幕，那我还是会买一台 24 寸的 1080P 。</p><h3 id="米家落地扇-1X"><a href="#米家落地扇-1X" class="headerlink" title="米家落地扇 1X"></a>米家落地扇 1X</h3><p>我原本以为风扇在我住这地方压根就没有存在的必要，这儿的天气要么就热死你，不得不开空调制冷。要么就冬天来了，用不上空调也更用不上风扇。但当我在 4 月份以 ¥223.20 拿下这台电扇后，虽然觉得有点小贵，可是却也一直吹到了冬天降温。只能说整体还行。</p><p>作为一个智能家居，可以不用遥控器，躺在床上就用手机控制开关和摇头，也一定程度上提升了幸福感我只能说。</p><h3 id="米家显示器挂灯-1S"><a href="#米家显示器挂灯-1S" class="headerlink" title="米家显示器挂灯 1S"></a>米家显示器挂灯 1S</h3><p>出租屋的灯管烧了，一直没叫房东换，就剩下个灯泡，勉强照亮整间屋子，但是桌面不够亮。于是 ¥188.87 入手了这个显示器挂灯，也挺满意的，有了它我甚至都不开灯泡了，反正屋子也不大，正常屋子里走来走去只要能看到路就行了。</p><p>同样作为智能家居，我可以爬上床了再用手机遥控关灯，半夜上厕所也可以遥控开灯再下床，有点爽。</p><h3 id="MX-Anywhere-3S"><a href="#MX-Anywhere-3S" class="headerlink" title="MX Anywhere 3S"></a>MX Anywhere 3S</h3><p>之前买过 MX Master 3S ，在 Mac 上使用，无论是通过蓝牙连接还是接收器无线连接，漂移、不跟手的现象都非常严重。在网上也看到有人反馈相同的问题，让我感觉这个产品本身就有问题……加上 Master 3S 体积较大，我的手小，最后二手出掉了。</p><p>用了一段时间的 Magic Trackpad 发现还是不习惯，最后买了个二手成色还行的 Anywhere 3S 。按键数量虽不及 Master 3S ，但是胜在大小合适，使用流畅。不过有一说一，两百八十多的价格还不包含接收器实在是有点贵了。</p><h3 id="避雷"><a href="#避雷" class="headerlink" title="避雷"></a>避雷</h3><ul><li>Bebird 可视挖耳勺，¥197.21 。没必要买我这款，买个基础入门款七八十块钱就 OK 了，像素提升带来的变化不大。</li><li>采邑折叠床，¥296.65 ，乳胶款 80*190 。没必要买那么贵的，拼多多百亿补贴买张一百出头的就行了，用坏了就扔，这个三百多的也不见得能用多久。不是针对这个品牌，而是这一类产品。</li><li>ATK Z87 Pro 机械键盘，￥314.00 。买回来用不到一个月就出现按键重复响应的问题，叫卖家换新也不肯换，维修还要我自掏运费。修好了寄回来发现相同的问题还是会偶尔出现一次，真的让我对这种国产品牌大跌眼镜。这个产品乃至整个品牌和店铺都要避雷。我之所以会买他们的键盘，是因为之前看到有人推荐他们家的鼠标，说是现在国产鼠标用很低的价格都能做出很高的质量了，结果没想到自己买键盘就踩到坑了，商家到后面甚至还把这个键盘下架了，笑死了，自己都知道产品不过关是吧。</li></ul>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>《炎炎消防队》简单的观后感</title>
    <link href="/posts/Review-En-En-no-Shobotai/"/>
    <url>/posts/Review-En-En-no-Shobotai/</url>
    
    <content type="html"><![CDATA[<p>能不看就尽量别看，快跑。</p><span id="more"></span><p>有些烂番我看完也就算了，但是能专门让我写出来吐槽的番就真的是属于那种烂到我每看一集都觉得无语的程度了。我不得已要大费周章组织语言把我的想法表达出来，一方面是为我曾经看过这坨屎留下痕迹，另一方面就是如果有可能的话，提醒没看过的人不要去看，能救一个算一个，再有一方面就是写点东西也算是对得起制作组拉的这坨大的。</p><p>顺带一提上一个把我恶心成这样的番是《租借女友》，但是和这个消防队相比，《租借女友》都还算好的了，至少人家只有 12 集，折磨也不用折磨你这么久，消防队竟然有 24 集，量大管饱，每看一集都是折磨，24 集下去，你也该像我一样怀疑人生了。</p><h2 id="背景设定"><a href="#背景设定" class="headerlink" title="背景设定"></a>背景设定</h2><p>每部番的前几集大多都会向观众大致介绍一下世界观背景及设定，然后在后续的剧情发展中再去不断地完善和补充相关信息。对于《炎炎消防队》来说，首先我承认其背景设定还算是令人眼前一亮、耳目一新，但是这部番的叙事还是很拉跨，因为它在后续的剧情发展中并没有去解答或是揭露一开始给我提出的问题和留下的悬念，抑或是它给出的答案让我感觉过于随意，并没有给我带来那种恍然大悟的感觉，也没有给我留下深刻印象。</p><p>比如我在看前几集的时候，我就有了以下这些问题：</p><ul><li>这个世界这个国家以前是什么样，经历了什么变成了现在这样？</li><li>人体为什么会自燃？火焰人是如何产生的？</li><li>有的人为什么能够掌控火焰？甚至掌控火焰的能力还会分等级。</li><li>……</li></ul><p>现在我整部番看完了，我也就知道了火焰人是人为制造的，制造火焰人的目的是为了寻找的新的适能者，以及那些能掌控火焰的人是通过「觉醒」才拥有了掌控火焰的能力，至于他们是跟虫子结合了才觉醒的还是怎么觉醒的我就不知道了，以及他们觉醒以后为什么还会分等级我也不知道了，难道有人觉醒得多有人觉醒得少吗？</p><p>你知道吗，无所谓了，我说实话我看完这部番的感觉就是吃完了一坨屎，我现在就只凭我的印象来写总结，以至于这些问题的答案究竟是什么，我已经没兴趣去了解了，毕竟你不会把时间和精力花在一坨屎上。如果我真要了解，那我还得二刷，乃至去看第二季和第三季……很难想象这种番能出到第三季。</p><p>接下来我想拿《进击的巨人》来简单做个对比，《进击的巨人》的动画现在已经完结了，但是我也只看了前两季，现在我同样列出几个问题：</p><ul><li>这些巨人是哪来的？</li><li>为什么这些巨人不会说话，大部分看起来都目光呆滞？</li><li>为什么巨人会吃人？</li><li>巨人的要害在哪里？在颈部？为什么是颈部而不是鸡鸡或者什么其它地方？</li><li>说到鸡鸡，这些巨人好像并没有鸡鸡，那他们是怎么繁殖的呢？</li><li>这些围墙是谁建造的？围墙里的生活持续多久了？</li><li>为什么人类只能在围墙内苟延残喘？围墙外的世界又是什么样的？</li><li>……</li></ul><p>同样是对世界观和背景设定进行思考和发问，巨人单单从提出问题的数量上就要多过消防队，而且每一个问题都能扩展出更多的问题，重要的是每一个问题的答案都是观众迫切想要知道的，你甚至可以想象观众在得到真相时那种受到冲击的样子。</p><p>而反观消防队，你甚至无法想象这部番它竟然要通过占用开头半分钟左右的时间来进行背景介绍，而且从第一集到最后一集都是这样。我不是说开头做背景介绍的番就是垃圾，而是首先你做的部分背景介绍的内容都是重复的你知道吗，其次你在做了背景介绍的情况下你的叙事还是这么拉跨，而且我想问一下你的世界观到底是有多大以至于你非得去做这个开头介绍呢？学人家做开头介绍，您做得明白吗？开头做背景介绍，中间还要有个标题转场，结尾还有个下集标题预告，完了加上 OP 和 ED ，正文压根就没剩多少时间了，再加上它本身叙事节奏又慢，你都不知道我看的时候有多他妈难受！</p><h2 id="叙事节奏"><a href="#叙事节奏" class="headerlink" title="叙事节奏"></a>叙事节奏</h2><p>提到了节奏我就顺着往下讲。这部番的节奏是真的慢，从头到尾没有意义或者意义不大的对话和动作太多了，我觉得它可能是想把高潮前的铺垫做好，以提升氛围和拉动观众的情绪，但是给我的感觉就是拖拉。我本来以为你们的冲突就要爆发了，太好了终于要开打了，结果你们还在那边巴拉巴拉小魔仙啰嗦一大堆？本来我情绪都到位了，给你们这样弄我又萎了，我还看个毛。</p><p>最搞笑的是什么你知道吗？我看前面几集的时候我记得有一集森罗跟亚瑟刚入队的时候，他们第一次出任务，剧情前面铺垫了一堆，完了真正进场办正事镇魂的高潮戏份的时间却只有一点点，然后就结束了，我他妈？？？我真的服了，搁这过家家呢？而且他们不仅仅是在开打之前话很多，打的时候话也很甜蜜多，以至于我在想他们是不是靠嘴来输出的。</p><p>例如 22 集，森罗和他弟正式交手，然后那个技术员在旁边观战。我草了我是真没想到他们三个人真的可以做到就是从开打前到打完了这一整个过程中嘴巴是没停过的。森罗先是在那里巴拉巴拉他怎么才能跟他弟一样使出那样牛逼的能力，然后他弟就在那里巴拉巴拉说森罗不可能打得过他&amp;森罗不是他哥&amp;他没有妈妈（是的，他竟然说出了他没有妈妈这种话，那你是怎么诞生的我想问一下，分裂出来的吗？还是从石头里蹦出来的？宁还是人吗？），然后那个技术员就他妈全程在那里讲解森罗和他弟的招式和原理……不是哥们儿，你是当我瞎还是怎么着？而且你觉得我会关心你们的招数是什么原理吗？而且你要解说，你就进行必要的解说就行了，没必要从头讲到尾啊。那个傻逼技术员，在森罗施展招式前就在讲他弟，在森罗施展出来以后就讲森罗，在森罗频繁施展以后就在讲过度施展的后遗症……我他妈真的是吐了，你不说话你会死？看 22 集的时候我是真的没忍住开了倍速看，不然我真的会吐，妈的。</p><p>我还是拿《进击的巨人》作一下对比，你能想象几个人在那里拼上性命斩杀巨人的时候，嘴巴还能叽里呱啦地说个不停吗？你能想象那些人在利用立体机动装置飞檐走壁的时候，还边走位边他妈讲相声吗？你能想象他们在那里殊死一搏的时候，旁边有个傻逼在解说他们的操作吗？</p><blockquote><p>哇！艾伦，你真的好牛逼啊，你的机动装置运用得简直炉火纯青，先是自由落体，然后将钩索射击并固定到高处，然后利用惯性以及装置的喷气动力把自己推动至巨人的脖颈处，再通过 360 度旋转劈砍巨人的脖颈，真的太厉害啦！</p></blockquote><p>我的意思是真正办正事打架的时候为什么废话要这么多呢？你就算要解说能不能只解说必要且重要的部分？剩下的内容观众难道不会自己看吗？请你搞清楚你是热血番，不是他妈的搞笑番，你的这些笔墨应该放在描写更加重要的地方上。</p><p>再说一下第 8 集好了，就是那个星星眼骗猫耳女让她带了一堆小朋友和一位女性到建筑物里的那集。那集的节奏也是真的慢，制作组好像就是蓄意要把星星眼刻画成那种十恶不赦的混蛋一样，先是让虫子爬到那个女的身上，让那个女的痛苦不堪然后自燃变成怪物然后星星眼再把那个女的杀了。然后星星眼再把猫耳女揍一顿，然后再把另一只虫子放进一个小孩身体里，但是这个小孩承受住了，这个结合就成功了，这个小孩应该就是有能控制火焰的适能者了。这一集几乎一整集都是在描写星星眼的这些恶行，直到最后森罗登场了，然后这集就结束了……也就是本来可以快速铺垫的，制作组就非得耗完这一整集，才让主角最后登场，至于登场后怎么样了，请看下集……这种硬拆成两集来放的行为会让我觉得制作组能力很一般，而且就算你这样拆，我也丝毫没有急不可耐想看下一集的欲望。还有一点值得一提的就是那个小孩，直到第 9 集结束了也没提到这个小孩怎么样了。不是哥们儿，这个小孩都和虫子结合成功成为适能者了，而且他这么小的小孩经历了这种事件，你们真的不用安抚一下他幼小的心灵然后顺便再教他怎么使用自己的能力吗？就直接烂尾了呗？</p><h2 id="人物刻画"><a href="#人物刻画" class="headerlink" title="人物刻画"></a>人物刻画</h2><ul><li><p>提到星星眼我就顺便来说一下这部番的人物刻画。首先还是讲一下这个星星眼，这个傻懒子全程就是瞪着他那双星星眼，然后说话带着自己的口头禅，他只要出场，无论是什么场合，都是那种开玩笑的形象。这种人物形象也算是日漫中比较经典的一种了，属于是那种让人看了就有种想抓来打一顿的冲动的形象。这样的形象，配合他所属的阵营，以及结合他第 8 集里的那些恶行，确实是让这个角色在我心里留下了印象，总的来说算是塑造得还行的角色了。虽然他的登场时间不长，就当个炮灰，两三集就下线了。</p></li><li><p>接着就是第三队的大队长，就是头戴乌鸦嘴面具的那个。我不知道制作组为什么要让他在登场的时候经常是表现出极度疯狂或者说癫狂的样子，给人一种心灵和身体都很扭曲的感觉，将某种情绪往一个方向推到了极致。结合这个人物的地位、年纪以及声音，我猜测制作组是不是想刻画一种反差的形象？但是给我的感觉就是很傻逼。比如他去杀那个 伏尔甘·乔瑟夫 那一集（第几集我忘了），他把伏尔甘打趴在地上，然后当着他的面把他的球敲坏，但是这个动作他要重复好多遍，边敲嘴里边叨唠着什么（具体是什么我忘了），总之这几秒钟画面就是在重复他的动作，制作组似乎是想给人一种他很癫狂的感觉……但是在我看来就是很傻逼，这种形象刻画大可不必。然后就是二十多集的时候，就是八队一行人到地下找白衣人的那几集，他们一行人到地下以后不是被烟雾分开了吗？伏尔甘和樱备大队长在一起，然后刚好遇到了乌鸦嘴，完了乌鸦嘴让丽莎（就红头发那女的）去把伏尔甘和樱备杀了，丽莎犹豫了，结果乌鸦嘴突然不知道怎么的就画风突变（一整个极度扭曲的画风和画面）出现在丽莎后面去命令丽莎……真的大可不必这样。</p></li><li><p>最后再来说一下主角森罗，这位更是重量级，我不知道《炎炎消防队》和《小丑》到底是谁借鉴谁，因为《小丑》中的主角亚瑟因为患有精神疾病导致他也是在不该笑的场合控制不住自己发笑，然后森罗也是这样。无论谁借鉴谁我直接说结论，《小丑》主角亚瑟的表演已经甩《炎炎消防队》几十条街了，森罗的笑简直就是拙劣的模仿，尤其是最后一集，你看看这是人能做出来的表情吗？你非得画一个这么扭曲的表情是为了什么呢？<img src="/../../images/ACGN/Review-En-En-no-Shobotai.jpg" alt="森罗的逆天表情"></p></li></ul><p>我只是觉得一个人物的形象刻画应该要更有内涵一些，从角色底层出发，通过角色的立场及行为举止来体现。而不是单纯地让角色的面部扭曲，或者是做出一些让人很难绷的动作来体现。森罗那个表情给我的感觉就是制作组刻意在我面前拉了坨屎，让我看屎的样子，闻屎的臭味，通过这种方式来刻画这坨屎。我的意思是你给森罗这样的表情是为了凸显他的悲伤之情吗？你大可给他一个正常的伤心表情或者是两眼失神的那种绝望表情，然后再从别的地方来进一步体现他此时的这种悲伤之情，而不是就做个逆天表情然后完事了。</p><p>通篇下来，我觉得比较正常或者说我比较喜欢的人物就只有八队大队长樱备和中队长武久火绳以及茉希了，其他人我真的难评，这些角色之间的互动以及刻意去营造的日常氛围总是能让我尬得抠出三室一厅。上一个能营造出让我觉得很尴尬的日常氛围的番是《妖精的尾巴》，但是人家该热血的地方是真的热血到位，不像《炎炎消防队》，干啥啥不行。</p><h2 id="结局"><a href="#结局" class="headerlink" title="结局"></a>结局</h2><p>最后再说一下结局，我是真没想到我追了二十多集结果就是看兄弟互认然后在那里小打小闹，感情搞了半天终于到了打 BOSS 的关卡结果 BOSS 是你亲戚呗，我想请问你见过哪部番结尾的高潮回是这种形式的？而且我本以为最后森罗他弟会洗白加入八队成为特殊消防员，和其他人一起踏上探寻真相的道路。结果结局是另外一个白衣人对他弟不知道念了什么逼咒语施了什么逼法术让他弟失去自我然后跟随其他白衣人离开了……那前面的那些战斗，以及八队的人迄今为止的努力又算什么呢？人家干了那么多活最后都到亲情互认的阶段了，你搞点小操作就把人家又拆散了？你的结局还能再随意点吗？</p><p>还有最后一集，最后一集没有什么打戏，纯粹是靠对话和叙事给观众带来情报，同时为下一季埋下伏笔。最后一集中，班兹大队长决定告诉森罗那场火灾到底发生了什么，但是首先他自己也说了，他是火灾开始 15 分钟后才到场的，既然如此那他所了解的过程肯定也是不完整的。其次班兹大队长一上来就告诉森罗他看到的那个头上长角的火焰鬼就是森罗他妈，可是班兹又是怎么确定那个鬼就是他妈的？因为房顶上那两个白衣人都说了，伪造他妈的尸体已经准备好了，班兹怎么就这么聪明直接忽略尸体，然后一眼丁真确定那个鬼就是森罗他妈？还有森罗他妈又是怎么就突然变成那种火焰鬼的？所以这最后一集看似讲了什么，实则又什么都没讲，我感觉也就是在最后的最后透露了最关键的一个信息：他们要寻找把火焰人变回人类的办法——仅此而已。</p><h2 id="累了"><a href="#累了" class="headerlink" title="累了"></a>累了</h2><p>我如果每看一集都做笔记的话，最后写起来肯定还会有更多的内容，因为整部番看下来让我感觉无语的地方太多了，以至于在看完结局以后，我是一点想看下一季的动力都没有。我感觉这部番要是放在十多年前可能还会有不错的分数，至少那时候的我还是个刚开始看番、不带脑子看番且尤其喜欢看后宫番的初中生，对番没那么挑剔。</p><p>就这样吧，暂时就想到这么多，不系统也不权威，想到什么说什么了，如果你有异议，不用跟我争，因为你是对的。</p>]]></content>
    
    
    <categories>
      
      <category>ACGN</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>《迷你忍者》通关感想</title>
    <link href="/posts/Review-Mini-Ninjas/"/>
    <url>/posts/Review-Mini-Ninjas/</url>
    
    <content type="html"><![CDATA[<p>是游戏，也是回忆和过去。</p><span id="more"></span><p><img src="/../../images/ACGN/Review-Mini-Ninjas.jpg" alt="通关后的界面截图"></p><p>这款游戏应该是 2010 年上市的，然后我应该是 2012 年还是 2013 年的时候才玩，当时还是个初中生，电脑配置很差，好在游戏本身走的卡通风格，对电脑配置要求不算高。简单对游戏进行评价总结就是：画风可爱，剧情也不算很复杂，游戏难度也能接受，一路闯关还会解锁各种法术和可操作的伙伴角色，还能持续升级，对当时我的来说也算是个好游戏，有一定的吸引力，整体给我留下了不错的印象。</p><p>但是我玩游戏有时候就挺奇怪的，像这种单机游戏，有时候玩着玩着就突然不想玩了，我记得当年应该是玩到在墓地取日光术的 kuji magic 那一关之后就停了，这一停就停了十多年，后来在 Steam 买了正版，但是也一直没玩。在 2024 年的今天，这款游戏还能正常在 Windows 10 上运行，可见优化和兼容性做得有多好。唯一的问题就是没有声音，需要安装一个叫 openAL 的音频库才行，还有就是有时候玩着玩着会出现类似电流音的杂音，不过也都问题不大，重启游戏就行了。再有一点就是没有汉化，三大妈的汉化会覆盖游戏主程序，应该是属于“外挂”类型的汉化？懒得纠结了，总之如果安装了，启动时就跟 Steam 没关系了，你的游戏时间 Steam 也不会记录。不过也好在如今英语水平也算有长进，再加上游戏本身也没什么复杂的剧情和对话，所以就直接吃生肉了。</p><p>接下来就是吐槽环节：</p><ul><li>游戏中的路线会有分支，你走哪条都能到达目的地，并且沿途也有需要收集的物资，但是你走一条，就意味着你需要放弃另一条路上的物资，如果你想要全收集，就有可能需要折返或者重玩这个关卡，对我来说，我觉得太麻烦了，我想一次就收集完；</li><li>使用「Spirit form」忍术控制动物时可以获得物资高亮视野，但是这也意味着如果你想要更好地收集物资，你就要时不时甚至是一直处在控制动物的状态下，因为真的会有植物藏在很不起眼的地方，而且你变成动物以后，我总感觉很多动物的移动速度很慢。</li><li>……</li></ul><p>我操，仔细想想，除了上述这两点，好像我也挑不出什么其它毛病了，而且这两点还是制作组为了增加游戏时间而刻意设计的收集成就，真要说是毛病倒也犯不上，只是我的吐槽而已。所以这么看来，这款游戏就和当年的《虐杀原形》一样，就是多数人的童年和青春，就是很不错的游戏。如果真要说有什么值得改进的设计，那就是等级上限只有 15 还是太低了，我感觉我满级后的经验应该可以让我继续升到 17 级这样。</p><p>游戏中的关卡，一路上，时间从白天到傍晚，从傍晚到黑夜，再从黑夜到日出，制作组真的有用心在设计场景，仿佛我们真的在赶路似的。然后场景就从竹林到山间，从山间到达敌人的城堡，从城堡再到村庄，从村庄到雪地，每个关卡的场景也和关卡 BOSS 有一定的关联。然后还有天气，从阳光明媚到狂风暴雨再到冰天雪地（人物在雪地里静置一段时间甚至还会冷得打颤，太细节了）……这些风景虽然不能说非常惊艳，但是每个关卡的场景设计都有一定的特色，让人愿意停下脚步来观赏一番，对于如此体量的游戏，我觉得这就够了。</p><blockquote><p>8&#x2F;10</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>ACGN</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>《方舟：生存进化》Steam 100 小时游玩感想</title>
    <link href="/posts/Review-ARK-Survival-Evolution/"/>
    <url>/posts/Review-ARK-Survival-Evolution/</url>
    
    <content type="html"><![CDATA[<p>骂通配符之前先把傻逼 Steam 也顺带骂一下，如果你在评测窗口修改了你的评测内容，然后切换评价类别（例如你从好评切换到差评），那么你所有的修改的内容都会丢失，是的，就是这么傻逼。</p><span id="more"></span><h2 id="87-小时游玩测评"><a href="#87-小时游玩测评" class="headerlink" title="87 小时游玩测评"></a>87 小时游玩测评</h2><p>87 个小时，跟着听宇的脚步，拿下了 5 个神器，但是还没有打蜘蛛，看了听宇打蜘蛛的那一期视频感觉有点麻烦，就有点不想玩了。我玩沙盒生存游戏就是这样的，上瘾的时候很上瘾，但是当下一个目标有些难以实现的时候，就有点不想玩了，之前玩 Minecraft 的时候也是这样。包括我这个人也有点奇怪，这 87 个小时当中我也使用过指令或者创造模式来避免太肝，但是这些东西一旦用过一次以后，之前那些通过肝，一点一点积累起来的成就彷佛就一瞬间消失了……通过作弊来达成目标一定程度上会让你失去玩游戏的兴趣，但是不这么做，你又需要花费大量时间来做重复的工作，太矛盾了。其实我玩其它的单机游戏也会作弊，因为我觉得我玩游戏就是为了开心而已，适当地作弊会让我轻松许多。但是问题在于，作弊对于这种模拟类型的生存类型的游戏影响比较大。</p><p>游戏是个好游戏，创意和想法都很不错，前几天看了人家一个一个小时的剧情介绍视频，了解到了原来游戏背后还有这样的世界观，又给这个游戏加分不少。尽管如此，基于虚幻 4 打造的生存进化无论是在画面还是在物理引擎上都还是有些许不足，晚上黑的时候伸手不见五指就不说了，从真实的角度来看，晚上在没有月亮和任何光亮的时候确实很难看见东西，我就当你是拟真吧。但是白天的时候亮到瞎眼就离谱了吧？甚至暗的地方又太暗毛都看不清又是什么情况呢。还有物理引擎，有时候恐龙卡恐龙或者恐龙卡地形真的挺烦的，说到卡地形，大部分原因也是因为寻路 AI 不够智能，甚至有时候吹了口哨了，恐龙还在原地看天发呆……</p><p>不过小毛病归小毛病，回到我之前说的，游戏的创意和想法真的很不错，驯养恐龙这种事情前所未有，简直太酷了，从只有一条内裤到成为岛上的霸主，那些几百上千小时的老玩家回头看向自己走来的路的时候，刚上岛被各种肉食性恐龙追着跑的画面也会历历在目吧。通配符也在几年时间里持续为游戏开发新内容和修复 BUG ，这些付出也算有目共睹。在听宇的视频里看到他几次提到方舟对中文输入法不友好，目前我自己玩下来，感觉中文输入已经完全没问题了。不过游戏倒是偶尔还是会闪退是真的，有一次我用剑龙采集石头的时候闪退了，有一次我从背包里丢东西又闪退了（就是虚幻引擎报错了）……幸好即使你不退出到游戏主菜单，游戏也还是会阶段性保存一下，不然就真的全完了。</p><p>87 个小时离体验完这款游戏（包括 DLC）来说还差得太太太太太太太太远了，但是我已经有点累了，我在想剩下的内容不如就看听宇的视频云通关得了，但是后续我可能会买飞升，用从进化这里积累的经验，在飞升里再开个存档慢慢玩一玩。毕竟飞升在新引擎的加持下，除了比较吃配置以外，全新的画面表现和新的特性以及优化过的游戏设定还是让我有些期待的。其实我最早是在 Epic 上玩进化的，当时是 2021 年，因为当时 Epic 送了进化，我领了就玩了，所以严格来说，我的游戏时间应该至少有 100 个小时，不过这和其他人比起来也不值一提。</p><p>联机部分我就不评价了因为我没联机过，第一是因为没朋友，第二就是看评论很多人说联机其实体验可能不咋地，服务器延迟高，有 BUG ，有外挂等等。但是就算是作为单机来玩，方舟也很耐玩了。</p><h2 id="100-小时游玩测评"><a href="#100-小时游玩测评" class="headerlink" title="100 小时游玩测评"></a>100 小时游玩测评</h2><p>87 个小时的时候给了好评，但是后续又忍不住玩了几个小时，然后遇到了点影响游戏体验的问题，左思右想干脆回来给差评，反正免费获取的游戏的评测也不会被统计到最终评分中。</p><p>我遇到的问题具体来说就是我的阿根廷巨鹰抓不起野生生物，网上一查发现这竟然是由于简体中文所导致的一个 BUG ，而这个 BUG 直接导致我错过了两个我很想抓的生物：</p><ol><li>我在红树林的河里发现一只一百一十多级的水獭，我下河里打它一拳把它引上岸，想着用我的老鹰把它抓走丢进困龙房里，结果抓不起来，然后它还莫名其妙在我老鹰的脚下消失了，是的，就是凭空消失的那种。</li><li>还是红树林，我发现了一只绵羊，我寻思着我的毛发材料有着落了，遂骑老鹰抓之，鼠标右键和键盘 C 键都试过了，都抓不起来，旁边霸王龙看我像看傻子一样，就直接过来帮我把绵羊咬死了，我的绵羊死了，通配符的妈也死了。</li></ol><p>而且由简体中文引发的问题还不止这一个，据悉是有二十几个，贴吧还专门有人做了相关补丁来解决这些问题，我还看到有人说切换游戏语言也能解决。不想打补丁的我试了一下将游戏语言切换为繁体中文，结果老鹰现在确实能抓起水獭、绵羊、星尾兽等等这些生物了，而且梁龙终于不用再背负盗首螈之名了，我真的服了。</p><p>我就纳闷了，这种这么明显这么影响游戏体验的 BUG 通配符怎么就不知道修？我知道你们现在是把精力都放到飞升上了，但是你也不能让进化就这么烂尾吧？其它那些难以复现的问题（比如我之前用甲龙采集石头金属的时候游戏闪退，以及我从背包里扔东西游戏都能闪退）不管就不管了，反正也是小概率事件，但是这二十几个问题，都是极其影响游戏体验的，玩家都已经收集好了的，就不能花点时间解决一下？我也算是有点庆幸没花钱买这游戏，就是不能给这傻逼通配符一点钱赚。</p>]]></content>
    
    
    <categories>
      
      <category>ACGN</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>聊聊苹果今年的新系统</title>
    <link href="/posts/Review-iOS18-and-macOS15/"/>
    <url>/posts/Review-iOS18-and-macOS15/</url>
    
    <content type="html"><![CDATA[<p>已<del>升舱</del>升级至 iOS 18 ，感觉良好……</p><span id="more"></span><h2 id="更新亮点"><a href="#更新亮点" class="headerlink" title="更新亮点"></a>更新亮点</h2><p>已经把 Mac 和 iPhone 的系统升级到今年的新版本了，就算把 AI 抛开来看，我感觉今年的系统也比前两年更有吸引力，让人更想升级。</p><h3 id="iPhone-镜像"><a href="#iPhone-镜像" class="headerlink" title="iPhone 镜像"></a>iPhone 镜像</h3><p>这是需要你有一台 Mac ，同时 Mac 和 iPhone 都要更新到今年发布的系统版本后才能使用的功能。这也是今年的更新中我最喜欢的功能之一，说白了，它就像一个 iPhone 版的 Android 模拟器，你可以用它在 Mac 上直接操作你的 iPhone 。有了它，我现在可以不用拿起 iPhone 就能看短信验证码了，甚至也可以直接在 Mac 上肝我的手游，很方便。</p><h3 id="密码-app"><a href="#密码-app" class="headerlink" title="密码 app"></a>密码 app</h3><p>iPhone 「设置」中密码相关的功能被拎出来单独作为一个 app 了。我应该是从去年开始全面转向并依赖 iPhone 自带的密码管理器的，我用它来保存和更新我所有账户的密码。唯一的问题就是每次想要进入到密码管理的界面，都要先打开设置，然后在顶部搜索栏搜索「密码」，然后点击搜索结果中的「密码」，然后 Face ID 认证，然后才能进入密码管理界面执行我的操作，真的很麻烦。现在它作为一个 app 存在，打开和使用不仅更方便，而且还能在 Windows 上使用了。</p><p>但是！但是它在 Windows 上的使用体验仍然是一坨狗屎，有多狗屎？总之它就是不能复制在 macOS 上的体验，给我一种 Apple 团队在做任何非 Apple 平台上的事情的时候都是随随便便的感觉，这个软件哪怕我把它写成一坨屎，但是因为它是为了给你们这些低贱的 Windows 用户使用的，那也就无所谓了，也就可以理解和原谅了。</p><h3 id="其它更新"><a href="#其它更新" class="headerlink" title="其它更新"></a>其它更新</h3><p>iOS 今年开放了更多的自定义选项，包括：</p><ul><li>主屏幕的应用图标现在可以自由拖放来自定义位置，同时应用图标的颜色可以进行统一设定；</li><li>控制中心现在可以自定义开关的数量和大小以及位置；</li><li>锁屏界面左右下角的两个快捷入口现在也可以自定义了；</li><li>……</li></ul><p>除了界面上的更新，在功能上，今年的新系统也带来了更强大的计算器（现在可以进行科学计算和单位换算了）。</p><p>当然了，也有没用的更新，比如 iMessage 和 FaceTime 上的更新，毕竟在中国大陆大家基本都不用这两个 app 。</p><h2 id="更新得不错，要我夸你吗？"><a href="#更新得不错，要我夸你吗？" class="headerlink" title="更新得不错，要我夸你吗？"></a>更新得不错，要我夸你吗？</h2><p>到目前为止，虽然 AI 相关的功能依然在画饼，但是已有的这些新内容仍然可圈可点。但是当我坐下来审视这每一个新功能时，我发现它们无一例外几乎都是挤牙膏挤出来的，或者是抄作业抄出来的。</p><p>先说前者，iPhone 镜像至 Mac 其实早在几年前的 WWDC 上就已经发布了，具体是哪个版本我忘了，尝试在网上搜索过了但是也得不到准确的答案。当时这个功能只能让 iPhone 的屏幕显示在 Mac 上，操作还是要在 iPhone 上进行，只不过你可以利用 Mac 的大屏和扬声器来获得更好的观看效果。这个功能非常鸡肋，我只用它来做一件事，就是吃饭的时候，打开手游，然后播放剧情，用来下饭。而现在，苹果利用其强大的挤牙膏功法将这个功能进行了扩展，让你得到了一个你可以在 Mac 上直接控制 iPhone 的功能。也就是说，苹果其实可以一步到位把这个功能做出来，但是它就偏要慢慢挤牙膏。而且如果你还想要像我一样用大屏放手游剧情，你就还是得回到原来的屏幕镜像，因为在 Mac 上控制的这个 iPhone 的屏幕既不是最大化的，也不可调节。</p><p>接着我们再说说后者，也就是「抄作业」。无论是 iOS 上新增的各种个性化选项，还是 macOS 上的窗口布局（妈的这种更新都能在发布会上拿出来说，可见得苹果是真的没什么拿得出手的了），都是其它厂家早都已经做了的，苹果也没见得做得比它们好，但是它就是要拖到现在才来做，说到底就是抄作业，而且抄得还慢。</p><p>说了那么多我其实就是想表达：我们应该以什么样的态度来面对苹果这几年包括今年在内的软件更新？确实，苹果今年带来了很多不像「苹果作风」的功能，这些功能可能早就是用户们期待已久的了，苹果终于在今年把它们端上了桌，那——</p><blockquote><p>我们应该感激或者说感恩吗？</p></blockquote><p>我操，那可真别，实现这些功能本就没什么难度，而且别人家早就有的东西，你苹果今年才拿出来，我都不好意思跟别人说你今年更新了这些东西，我真的丢不起这个人，说多了等下真让人觉得你苹果畜牧业做得好，是真会调教用户。对于苹果这种扭扭捏捏拖拖拉拉的软件更新，我只想狠狠地问候软件团队，尤其是那个每次发布会都摆着让人绷不住的站姿的 Craig ，你们要是不知道更新啥，不如去看看 Smartisan OS 或者其它国产安卓 ROM 有啥功能就随便搬点过来吧。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Arc 浏览器使用感受</title>
    <link href="/posts/Review-Arc-Browser/"/>
    <url>/posts/Review-Arc-Browser/</url>
    
    <content type="html"><![CDATA[<p>好像确实也没大家说得那么好用，至少我个人用下来觉得一般。</p><span id="more"></span><h2 id="本身就一堆小问题"><a href="#本身就一堆小问题" class="headerlink" title="本身就一堆小问题"></a>本身就一堆小问题</h2><p>这是我上手这个浏览器仅仅一天就发现的问题，排名不分先后。</p><h3 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h3><ol><li>界面无中文，桌面端没有，移动端也没有，简体中文没有，繁体中文也没有。很难想象这是一个从 2022 年 4 月 19 日发布至今的产品。硬要说一点也没有那倒也不是，网页右键菜单是中文，<code>arc://settings/</code>页面有中文，但是又没翻译全，仍然有部分英文。</li><li>同步数据需要科学上网，这点很麻烦。你可能会说：“那 Chrome 也需要啊”，你说的对，而且不止 Chrome ，Vivaldi 现在也需要……但是它们与 Arc 不同的地方在于，当它们使用扩展程序来接管浏览器的代理时，它们就可以通过扩展程序代理的网络来进行数据同步，但是 Arc 就不行，它一定要是 TUN 模式这种接管系统流量的方案才能进行同步。顺带一提，Chrome 和 Vivaldi 就是因为有需要科学上网才能同步账号数据的限制从而降低了我的使用欲望，于是我现在才开始到处找 macOS 上 Safari 的代替品。</li></ol><h3 id="体验感撕裂"><a href="#体验感撕裂" class="headerlink" title="体验感撕裂"></a>体验感撕裂</h3><p>当你打开浏览器的「偏好设置」（也就是 Preferences ）时，Arc 会弹出一个窗口，你可以在其中进行部分主要设定，但是当你点击「Advanced」标签，然后点击「More Settings…」按钮时，Arc 就会打开 Chromium 原生的设置页面，这种体验上的割裂感让我十分不适。我觉得你要么就直接把所有设置项都放到你自己创建的窗口里，不然你就直接把 Chromium 原生的设置界面搬过来用也不会有人说什么，做了一半剩一半你不如不做呢？</p><h3 id="喜欢吗？喜欢就砍了！"><a href="#喜欢吗？喜欢就砍了！" class="headerlink" title="喜欢吗？喜欢就砍了！"></a>喜欢吗？喜欢就砍了！</h3><p>Note 功能到哪去了？从这支影片 <a href="https://www.youtube.com/watch?v=nlNsCB4SbVc">Arc 真香！腦洞大開的功能讓超多 Chrome 死忠粉決定把 Arc 當作預設瀏覽器了！</a> 的 9:57 处可以看到，当你点击侧边栏下方的 + 号时可以在弹出的菜单中看到「New Note」这个选项，通过点击它你可以创建一个笔记。但是我现在在使用时却没有这个选项了，我估计它应该是和 Easel 整合起来了。可是为什么要这么做呢？在 Easel 上你可以在页面的任何位置创建文字，这在联想或者记录灵感时十分有用，但是当我只想一行一行有序地记录文字时（就像使用 Word 那样），Easel 明显就不行了。</p><h3 id="强制垂直标签页"><a href="#强制垂直标签页" class="headerlink" title="强制垂直标签页"></a>强制垂直标签页</h3><p>在 Microsoft Edge 、Vivaldi 等浏览器中，你可以选择标签页的位置，或位于顶部，或位于左&#x2F;右。但是在 Arc 中，你只有一个选择，那就是放在左边。无论这是否挤占了网页的显示空间，无论这是否能提升你的效率，你都只能放在左边。当然，你可以选择将侧边栏隐藏，在这种情况下，当浏览器上没有活动标签时，侧边栏会自动出现，有标签时，侧边栏会隐藏，当你把鼠标移动到屏幕左侧时，侧边栏也会弹出——就看你能不能习惯和接受了。</p><h3 id="性能错觉"><a href="#性能错觉" class="headerlink" title="性能错觉"></a>性能错觉</h3><p>我刚开始打开 Arc 浏览网页，感觉它的反应真快！难道它确实是优化做得非常到位，代码写得非常好？直到我打开了设置，发现它的「预加载网页」默认是打开的，但是在别的浏览器中，这个功能我是默认关闭的。</p><p>其次在「预加载网页」的上面有一个「省内存模式」，这个它反而默认是关闭的……诶我就纳闷儿了，你这么爱把标签页 pin 住，但是对于那些 pin 在那里但是暂时用不着的标签页你为什么不把它们的资源释放出来呢？</p><h2 id="「无书签」并不适合所有人"><a href="#「无书签」并不适合所有人" class="headerlink" title="「无书签」并不适合所有人"></a>「无书签」并不适合所有人</h2><p>「无书签」的设定可以说是 Arc 浏览器的一个特点，它把书签所承载的功能移交到 tab 、space 等概念上了，再结合 pin 这个动作，试图取代书签。事实上，书签功能在 Arc 中并没有被完全移除，只是被藏起来了。我们仍然可以在地址栏手动输入<code>arc://bookmarks/</code>来跳转到书签页面，在这里我们依然可以编辑书签、导入和导出。但是问题在于，这个功能现在和浏览器已经是一点都不相干了，就算你导入了书签，你也无法在地址栏中通过输入已有书签的部分地址，然后让浏览器进行地址补全，因为浏览器根本就不补，它根本就不管你有没有导入书签，它同步数据的时候也不会去同步书签，并且 Arc 浏览器也没有「添加当前网址到书签」的功能。</p><p>但我感觉用户的使用习惯并不是能那么轻易改变的，至少我个人还是很依赖书签，经过这么多年的使用和维护，我现在依然存有上百个书签。确实，每个人每天要打开的网站可能也就那么几个，但是这不代表剩下那上百个书签对我来说毫无意义。既然你要“去书签化”，那你就把相关的功能给删干净了吧，删又不删干净，搞得我用也不是不用也不是。</p><h2 id="Max-里的功能简直可有可无"><a href="#Max-里的功能简直可有可无" class="headerlink" title="Max 里的功能简直可有可无"></a>Max 里的功能简直可有可无</h2><p>Max 是 Arc 提供的一些由 AI 驱动的功能，这些功能的动作基本上都是整理、重命名、快速预览、快速提问。这些功能共有 7 个，其中有一个叫「Ask on Page」，我输入了问题，Arc 加载了半天没响应。我以为是网络问题，我就开启 Clash 的系统代理——没响应，我开启 TUN 模式——还是没响应，那我还用个屁？后来我看了相关的介绍视频，发现这个「Ask on Page」的功能应该是结合网页内容来回答你的问题，也就是你问的问题要和网页内容有关……无论怎样我反正用不了。</p><p>如果你想不受限制地发问，你可以使用 Max 中内置的 ChatGPT 快速提问功能，但是这个功能也只是提供一个输入框给你输入问题，然后它就会跳转到 ChatGPT 的网页版，也就是说，当你输入完问题按下搜索以后，就没 Arc 什么事了……我也是挺无语的，而且通过这个搜索框创建的对话，ChatGPT 那边似乎使用的还是 3.5 版本的模型，这……</p><p>我再说说自动重命名功能吧，这个重命名主要分为标签页重命名和下载重命名，前者是对你 pin 的标签进行命名，我个人感觉没什么卵用，比如我 pin 了 ChatGPT ，Arc 浏览器就把标签页的名字改成「聊天GPT」，不是，这有什么必要吗？这也没让标签页变得更加直观啊。后者这个下载重命名我则是因为没下载文件所以没体验到，不过我觉得也是可有可无。</p><h2 id="也不能光骂不夸"><a href="#也不能光骂不夸" class="headerlink" title="也不能光骂不夸"></a>也不能光骂不夸</h2><p>浏览器本身也并非毫无亮点，且听我慢慢道来。</p><h3 id="界面设计优雅清爽"><a href="#界面设计优雅清爽" class="headerlink" title="界面设计优雅清爽"></a>界面设计优雅清爽</h3><p>Arc 浏览器的各种窗口效果、动画都做得很好，或者说都做得和 macOS 很搭，都有一种很优雅的感觉。你说颜值重要吗，它固然不是一个工具的核心，但「美」是人无法拒绝的。尽管这个浏览器用起来可能不是很顺手，让用户想立刻卸载了它，但是超高的颜值却又让用户在按下卸载按钮前多了几分犹豫。只是在新鲜感过后，Arc 要靠什么来留住用户，那就不得而知了。</p><p>好看又好用那就是宝藏，就是杀手级 app ；好看不中用，那就是花里胡哨，就是花瓶。</p><h3 id="还有吗？"><a href="#还有吗？" class="headerlink" title="还有吗？"></a>还有吗？</h3><p>还有……还有……呃……，哦对了，还有浏览器内置的截图功能，这应该是我用过的最好用的内置截图工具，截图时可以选择单个网页元素进行截取（跟 Firefox 一样），对强迫症非常友好，截图完成后可以进行标注……不过这个功能对于国人来说可能也没什么用，毕竟大家都喜欢用微信和 QQ 的截图。</p><p>还有吗？</p><p>还真没了，整体下来，Arc 浏览器能让我发现的优点也就只有「好看」这一个了。只能说独特的设计理念让它注定无法成为大众产品，我提到的毛病就有一堆，真要说实话那我是用哪哪不顺手，用了才一天就已经想要换回 Safari 或者 Firefox 了。其实最主要的还是网络问题，让体验大打折扣，GFW 真的该死啊。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>我 V 你 50 ，召唤仪式让我来做！</title>
    <link href="/posts/Review-My-Undead-Yokai-Girlfriend/"/>
    <url>/posts/Review-My-Undead-Yokai-Girlfriend/</url>
    
    <content type="html"><![CDATA[<p>今天看完了一个亚马逊的剧——《我的女友是妖怪》，我的评价是：好看，爱看，速速出下一季！</p><p><img src="/../../images/ACGN/My.Undead.Yokai.Girlfriend.S01E08.If.You.Love.Someone.1080p.AMZN.WEB-DL.DDP5.1.H.264-ZeroTV-0001.jpg" alt="OP 画面"></p><span id="more"></span><p>首先这部剧的受众群体是哪些人呢？虽然我不愿意承认，但是这种带有恋爱元素的喜剧片，同时女方又是强势的一方的片子，多半是给那些生活不顺的单身死肥宅男看的吧……我说的是我自己，如有冒犯还请原谅。像这种「女方强势」的类型的片子有很多，什么「我的老婆是赌圣」啊，什么怎么怎么的突然就被富婆爱上了这些，不过像这些在我看来都太 low 了，根本没兴趣去看，更别说看完了还在这里敲键盘。</p><p>那么本剧的亮点有哪些呢？从最表面上来看就是选角，选择 吉川爱 来饰演女主几乎是完美的，超高的颜值以及她在剧中的表演，会让你觉得她就是公主本人，这种契合程度就像：</p><ul><li>六小龄童 饰演 孙悟空</li><li>亨利·卡维尔 饰演 利维亚的杰洛特</li><li>安德鲁·加菲尔德 饰演 蜘蛛侠</li><li>小罗伯特·唐尼 饰演 钢铁侠</li><li>……</li></ul><p>除了女主，男主的父亲的选角也很不错，作为一位老父亲同时又是一位警署的队长，那种成熟沉稳的姿态、认真对待工作的态度、忽视了与儿子的相处与沟通等等一系列出演都十分到位。</p><p>男主呢？男主的设定就很奇怪了，因为我前面说过这种「女方强势」的类型的片子多半是瞄准那些生活不顺的单身死肥宅男去的，但是男主的各方面条件都不算差，要基友有基友，要社交有社交，家境也不差，老爸当警察队长，老妈每天早上起来做丰盛的早餐给大家吃，自己还是个大学生……你这样子让我怎么代入呢？我除了在「没有女朋友」这一点上和你一样，我其它地方怎么比得过你？反观男主自己，在有了这些条件的加持下，每天还是表现得那么唯唯诺诺……给我的感觉就像是剧情需要。</p><p>总之值得一提的也就这三个角色了，至于反派，也就那样，设定一般，出演得也一般。</p><p>等等，我为什么要说「反派」？这是个很有意思的问题，成年人的世界中不存在好人与坏人，只是大家的立场不一样罢了。这部剧中的“反派”的行动目的从表面上来看只是为了消灭女主，因为女主是妖怪，“反派”们是古代镇妖的「守护者」（在剧中被称为「五矛」），他们认为人类和妖怪是无法共存的，故而为了世界和平而消灭妖怪。而女主才更像是“坏人”，因为她为了解放她被封印的家人们，她自己一被召唤出来就杀了一个「五矛」的后代……所以到底是孰对孰错呢？</p><p>这里就不深入讨论了，只是想到了这个话题就随手写下来而已，我只是想说其他的角色，包括主角团的其他人和所谓的“反派”，大家的演出不能说很好，只能说是不算差。</p><hr><p>说完了角色，再来看看剧情。最近在刷抖音的时候经常看到一些影视剪辑下面跟着一个标签：「因为一个片段看了一部剧」……我看这部剧的契机也是因为我看了别人在 QQ 群里发的截图，截图的内容应该是第一集女主和男主签订契约的部分。你猜他们是怎么签订契约的？那当然不可能是白纸黑字，而是通过发生关系……虽然在剧中大家都把这段关系视为一种诅咒，不过这都不重要了。妈的能通过和美少女做爱然后让她和自己绑定在一起，然后她还是个什么公主，然后还是个狐妖，然后还法力高强，这种事情想想都让人流口水啦！</p><p><img src="/../../images/ACGN/My.Undead.Yokai.Girlfriend.S01E08.If.You.Love.Someone.1080p.AMZN.WEB-DL.DDP5.1.H.264-ZeroTV-0002.jpg" alt="让我来！"></p><p>咳咳，事实上，我想说的是，编剧在这方面确实是懂的，他懂得怎么在第一集就快速抓住人的眼球，因为他知道作品本身已经没有什么非常新的东西了，只能靠擦边球来留住观众，到了后面再慢慢通过矛盾和感情戏来加深观众与剧中角色的连结。整部剧只有 8 集，只有第一第二集有这种擦边球，到了后面也是只字不提了。</p><p>结局方面也是给到了我一点意外，前面提到女主为了解放她被封印的家人们而杀了一个「五矛」的后代，事实上，她需要杀掉总计 5 个「五矛」的后代并把他们的头颅放在法阵上才能解开封印。前面四个头颅都拿得挺顺利的，直到最后一集女主才发现，最后一个她需要杀的人——竟然是男主……你看看，所以我说编剧是懂搞矛盾的，这下是杀还是不杀呢？那当然是下不去手了对吧，先别提男女主的感情如何，从设定上来说，契约的任意一方死去，另一方也会随着死去，这下你是想杀也杀不了了23333。</p><p>这里还需要补充一点是我为什么说结局给到了我一点意外，因为一开始剧情中表明女主要杀的最后一个人其实是另一个角色，直到最后女主要下杀手的时候才发生了反转。那女主是如何定位要杀的人在哪的呢？因为连杀谁都搞不清楚的话你这个妖怪未免也太逊了，你这个设定做得不行。事实上，在剧中女主确实是有一个用于定位要杀的人在哪里的道具，但是这个道具似乎只能定个位置，不能定位到具体是哪个人。而男主到了后期就和女主以为要杀的那个角色一直在一个位置，所以直到男主最后拿着道具站在女主面前跟她说明真相之前，大家都是蒙在鼓里的，包括男主自己，因为他一开始也不知道自己是「五矛」的后代之一，而那个定位道具也不是一开始就在女主手上的。</p><hr><p>这么看来，在设定这一块，编剧还是下了点功夫的，不能说天衣无缝，只能说勉强合理。但是话又说回来了，这种一季只有 8 集的恋爱喜剧也没必要那么较真设定了，只要不是太离谱，大家看个爽看个乐就完事了。这就像你看死侍一样，他都打破第四面墙了，你还跟他谈什么正经？</p><p>总而言之，结局不说 happy 但也不算 bad ，女主的离开也让男主有所成长，「五矛」组织死了他妈 4 个后代了后续估计也不成气候了，估计编剧也要想想搞个新的“反派”集团出来了吧。</p><p>后续怎么样我不知道，我知道的是编剧在片尾留了很多很多很多很多坑，而且直接明示了女主还没死（甚至都没被封印回去），所以只要反响还行、经费足够，那我觉得是很有可能出第二季的。不过也不是说你有续集就是好事，你质量要是下去了那和喂大家吃屎有什么区别。</p><blockquote><p><strong>最终评分：8 &#x2F; 10</strong></p></blockquote><p><img src="/../../images/ACGN/My.Undead.Yokai.Girlfriend.S01E08.If.You.Love.Someone.1080p.AMZN.WEB-DL.DDP5.1.H.264-ZeroTV-0003.jpg" alt="男主最后也成长了"></p><p><img src="/../../images/ACGN/My.Undead.Yokai.Girlfriend.S01E08.If.You.Love.Someone.1080p.AMZN.WEB-DL.DDP5.1.H.264-ZeroTV-0004.jpg" alt="女主还在人间"></p>]]></content>
    
    
    <categories>
      
      <category>ACGN</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>正当防卫 3 - 测评</title>
    <link href="/posts/Review-Just-Cause-3/"/>
    <url>/posts/Review-Just-Cause-3/</url>
    
    <content type="html"><![CDATA[<p>历时 24 个小时，把《正当防卫 3》的主线推完了，也把空中和海上的 DLC 任务做完了，也把所有的地区都解放了，这么看来，整个游戏的流程也不算长。</p><span id="more"></span><p>这游戏是 2021 年 2 月 13 日买的，但是一直到现在才玩，很巧的是，二代是 2020 年 6 月份玩的，三代也是 6 月份玩的，可以说刚好隔了 4 年。</p><p>除了画面这种理所当然的进步以外，其它层面例如剧情、玩法都没有什么大的变化，剧情上也和前作没什么联系，所以就算没玩过前作，直接玩本作也不会说让人摸不着头脑。</p><p>正当防卫系列的主角都是里科（Rico）一个人，剧情上，里科在本作回到了自己的故乡梅迪西（Medici），并与自己的好兄弟等一众人一同推翻拉维罗（Ravello）将军的统治，解放故乡。仅此而已，跟前作一样，剧情上可以说是毫无深度，没有什么复杂的关系和背景，也没有什么尖锐的矛盾，这游戏的剧情就和它的玩法一样，简单粗暴，一句话就能概括。</p><p><img src="/../../images/ACGN/Just-Cause-3-1.jpg" alt="和兄弟一起解放家乡"></p><p>虽然玩法上没有太大变化，不过我在前作的评测中也没怎么提过玩法，这里还是简单说一下。在本作的地图中有十多个省份，每个省份中有一定数量的据点，这些据点可能是敌人的军事基地，也可能是由敌人统管的小镇等等，不同类型的据点只是需要破坏的建筑和设施的数量和种类不一样而已。所以无论是什么据点，你只需要进去，然后根据屏幕左边的提示，把里面需要破坏的东西例如水塔、广播、拉维罗将军的雕像等等统统 blow shit up 就行了。所以在游玩的过程中，新鲜感的来源之一就是你如何把这些东西炸毁，比如游戏本体可以允许你利用枪械和投掷物进行破坏，或者是用钩爪把油桶和需要破坏的设施连在一起，然后按下按键让油桶向设施靠拢，最后相撞产生爆炸。而 DLC 提供的内容就有意思多了：</p><ul><li>比如做完空中基地的任务后，我们的滑翔翼就有了喷射燃料的功能，这样我们就能持续滑翔了，同时滑翔翼还增加了机枪和导弹，这就让我们成为了人形自走战斗机。</li><li>我们在监狱解放了反叛军后还解锁了机甲，后续还能通过空投召唤机甲进行战斗。</li><li>在做完破坏黑手在海上控制天气的设施的任务后，我们还拿到一把叫「eDEN星火」的武器，这是我见过比较有创意的武器了：准星对准一个位置，长按鼠标左键使武器蓄力，蓄力完成后会从空中降下雷电对目标进行强力打击。</li></ul><p>此外，本作还增加了类似于 天赋&#x2F;技能树 的系统，怎么说呢，常规操作了，这游戏要是没有这系统才奇怪，毕竟这东西还是会增加一些玩家肝游戏的动力。</p><p>游戏全程就是 炸东西 → 做主线 → 炸东西 → 做主线。但是正当防卫系列的特色——钩爪，在本作还是有改进的。在前作的测评中我提到，前作里的移动基本上只能靠你那逼钩爪，并且距离十分有限。但是本作增加了在使用钩爪时可以打开降落伞和展开滑翔翼的功能，其中滑翔就可以让你以较快的速度进行移动了。我个人在前期一般在使用完钩爪后会先打开降落伞，因为这会使我的高度提升，然后我再开启滑翔翼进行滑翔。</p><p><img src="/images/ACGN/Just-Cause-3-2.jpg" alt="传统艺能-骑导弹"></p><hr><p>说完了剧情和改进的地方，接下来我就要开喷了，排名不分先后。</p><ol><li>首先，这个逼游戏还是没中文。</li><li>我估计用手柄玩这游戏的体验应该不是很好，前期我用手柄试玩了一下，发现这逼游戏没有给射击提供辅助瞄准的功能，射击的体验简直一坨。还有，游戏在用键鼠操作时，鼠标左键是射击，鼠标右键是钩爪，那我就很好奇，开镜瞄准应该怎么触发？噢，原来是要按下鼠标滚轮……而且开镜瞄准，或者叫精确瞄准，这个功能还要你到天赋树里把它点上它才能用，这是我见到的第一个要点技能才能精确瞄准的射击游戏。</li><li>当你按下 Esc 键打开菜单时，你可以再按一次 Esc 键将其关闭，但是当你进入子菜单或者说当你进入次级菜单的时候，你必须要通过按下 Ctrl 键来返回上一级，我都傻了。</li><li>车辆的的驾驶手感简直就是一坨。</li><li>物理引擎有些怪怪的，你说它真实吧，它在某些方面的细节也确实到位。比如直升机降落在草地的时候，附近的花和草都会因为降落带来的强力的风而摆动。但是有时候这个引擎又会让你觉得很抽象，比如当你从滑翔状态变成降落伞状态的时候，你滑翔时的那个速度似乎并没有继承到降落伞这里，并且当你收起降落伞的时候，引擎会让你的人物直接 90° 自由落体。</li><li>还有个问题就是战场上总是伴随着各种爆炸和枪声，人物之间的对话基本上听不清。</li><li>感觉游戏内还是比较缺乏指引性的提示，比如在破坏据点的时候，有时候就剩那一两个建筑或者设施，但是你总是找不到，这就会浪费一大堆时间。后来我才发现，这时候你打开地图，那些还没被破坏的设施会在地图上显示出来，但是你不跟我说我怎么知道？我光看着 HUD 上的小地图了，小地图上就没有菜单里的大地图这么详细啊。其实这也还好，因为最难受的是有时候你都不知道一个任务点该从哪里进入。</li><li>还有，我很不喜欢这种实时联网上传分数跟别人进行排名的功能。且不说有没有意义，在中国这种网络条件下，GFW 会教你做人，在没有加速器的情况下，玩这个游戏时不时就会弹个窗口出来跟你说连接服务器失败，体验真的很差。</li></ol><p>基本上就是这样了，我玩这游戏还是要开修改器，没那个耐心慢慢玩。但是你要说它很烂，当你回头看到游戏本体和好几个 DLC 加起来也才十几块钱的时候想想也就算了。最终评分 6&#x2F;10 。</p><p><img src="/images/ACGN/Just-Cause-3-3.jpg" alt="风景还行"></p>]]></content>
    
    
    <categories>
      
      <category>ACGN</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>我还活着呢</title>
    <link href="/posts/I-am-not-dead-yet/"/>
    <url>/posts/I-am-not-dead-yet/</url>
    
    <content type="html"><![CDATA[<p>虽然活得挺郁闷。</p><span id="more"></span><p>距离上一篇 post 直接就过去了半年是真他妈牛逼，来看看这半年我都经历了什么……首先是上篇 post 写完没几天就被辞退了，刚好卡在试用期快结束的时候，理由是公司业绩不太好，为了降低成本，暂时不需要这么多人。于是我们技术部门先是干掉了一个前端实习生，然后一个后端说要去别的地方发展也就随着走了，紧接着就是我，整个部门最后只剩下主管一个人。我进公司的时候，公司在 Boss 直聘上还挂着好几个岗位，我进公司以后，后续才进来了前面说的那个后端工程师和前端实习生，然后美术部门那边也招了两个，我是不太清楚业绩和环境发生了什么变化，能让我们在短短三个月时间就经历从招人到开人。</p><p>不过有些事情也没必要过于纠结，真正需要考虑的是再就业问题。那几天就在公寓里投简历，甚至有一天出现了把 Boss 直聘当天的投递次数全部用完的情况。投了刚好一星期，去面了一个在附近做机器人的公司，结果是没有结果。好在当时租房的时候只短租了 3 个月，找不到工作可以暂时回亲戚家住着。回去后的某天亲戚就跟我说她学姐在朋友圈里发布了招聘公告，我记得当时也没跟我说具体招聘什么岗位，只是模糊地描述了一下，说是当个司机之类的，然后又说这位学姐颇有家资，家里有游艇之类的。然后如果我感兴趣的话她可以帮我联系，然后我再自己去面试。一开始我还带着开玩笑的心态想难不成是什么富婆招司机？难道我的机会来了！？结果到地方了才知道，招聘的是销售岗位……果然码农的结局都是销售和摆摊炒粉吗。</p><hr><p>首先，销售的产品是塑料原料，具体来说就是工程（改性）塑料的粒料。所谓「粒料」就是一小粒一小粒的塑料原料，所谓「改性」就是在塑料原料的基础上添加新的特性，例如使其更加坚硬，或者是使其能够阻燃等等。这样的岗位和销售内容的组合早在十几二十年前就有了，尤其是在零几年的时候。且不说销售员，当时花点钱买几台注塑机开工厂的老板基本上都能赚到钱，注塑机在当时说成是「印钞机」也不为过。只不过入局的人越来越多了，竞争越来越大了，再加上疫情这几年，使得本就大不如前的行情更是雪上加霜。</p><p>进一步了解后我才明白，我们的办公室其实是公司位于本地的办事处，公司本部及生产车间并不在这里。而我这个岗位也是因为目前在任的同事想要离职了，所以才需要临时招聘继任的人。而据我了解，目前在任的这位前辈之所以会来到这里，也是因为之前在任的人要跑路了，如果之前的人不走，那这个岗位其实也不缺人。</p><p>总之在经过一上午和领导的沟通，以及好几天跟在前辈身后的学习之后。我就带着不情不愿、不排斥也不感兴趣的心态上岗了。然而就是因为这样的态度，再加上工作上遇到的各种糟心事，我在上岗一个月后就想跑路了，尽管在亲戚、家人以及领导的鼓励下稍微调整回了状态，但是好景不长又会再一次跌入谷底……这种反复出现的情绪低落和毫无干劲就像大姨妈一样折磨着我，甚至严重到了让我每天早上起床睁开眼睛后想到的第一件事就是辞职的地步。最终再也坚持不住，在干了 5 个多月后离开了。</p><p>当初第一天和领导见面沟通的时候，她就跟我说这个行业和这个岗位可以为我创造不小的财富，只不过需要投入几年的时间来入门，而她也到了退休的年纪，希望找个人来接班……我倒不是说她说的有什么不对，只不过这些话从她作为领导的口中说出来只会让人感觉到像是在 PUA 和画饼。既然这个工作这么好，那为什么还会有这么多人相继离开？其工作内容和工作环境究竟如何？好吧，且让我回忆回忆：</p><ol><li>公司（办事处）规定上午八点半上班，下午五点半下班，你必须准时上班但是不一定能准时下班。开车出差是常有的事，一周 6 天班你可能有 5 天是要出差的，我经常在没吃晚饭的情况下七点多八点钟才回到出租屋，吃个饭洗个澡就已经九点多接近十点钟了。如此工作，完全没有自己的时间，说不好听的比当兵还难受。</li><li>全年单休，甚至就连法定节假日都会打折扣（因为工厂上班了，或者说客户上班了，所以我们也要跟着上班）。例如今年的中秋国庆假期，公司规定了 4 号就要上班。本来每天工作时间就长，现在连假期都没剩多少，感觉这就是销售人的日常了。【你这么努力工作，一定很有钱吧.jpg】</li><li>虽然是销售，但是仍然要了解产品特性和掌握一定的专业知识。有很多优秀的销售员，都是从他们的产品部门或者开发部门转过去的，借助他们原有的知识储备，就能让他们在销售路上走得更快更远。那么问题就来了，如果你销售的产品和你的专业八杆子打不着怎么办？「好！勤能补拙，把本就不多的业余时间投入到对所销售的产品的学习和了解中去！」说得简单，倘若是你本身对这方面又一点兴趣都没有呢？反正我作为一个软件工程专业出身的，那些化学相关的课本对我来说宛如天书。如果你让我去卖手机或者卖新能源汽车等等这些科技电子产品的话，我还会有点兴趣。所以这就是这个工作最困难且最枯燥无味和打击人的部分了，你要在既没有行业经验，又没有专业知识，甚至还和客户有年龄代沟导致没太多共同话题的情况下，去和客户聊业务、谈天说地。我真不知道怎么谈得下去。</li><li>除了「和客户了解需求，把产品推销给客户」这种销售的分内之事以外，这个岗位还充斥着大量“擦屁股”的工作。比如和本就不好沟通的客户对账、催款等等。客户不好沟通就算了，这个公司里面的部分同事也是不知道该说是态度有问题还是怎样，有时候请他们协助办件事半天没回应的，真的这么难配合吗？</li><li>领导是个更年期女强人，大部分时候都在唠唠叨叨，她的出发点也许是好的，但是这样唠叨个没完真的很烦人。很多很简单的道理总是要重复很多遍，好似把我当成从那山里出来的野人一般，和她共事不亚于孙悟空在西行路上听唐僧问了他一路「悟空，你知不知道什么是铛铛铛铛铛？」这里就不得不提到公司总部的老板，老板在自己出来创业建厂单干前也是某个做塑料的企业的销售员，并且他的业务能力相当不错，业绩也很好，当时已然晋升至经理，下面带着一批销售员。自己出来开公司以后，他还是会亲自上阵跑业务拉客户。「思维敏捷，思路清晰，专业知识到位，擅长沟通」，这是总部老板给我的印象。对于一个问题，他能很快给到你正确的答案和处理方式，非常爽朗，一句话能讲清楚绝对不会反复唠叨拖泥带水，非常符合我对那种创业成功中年男性的印象。之所以提到总部老板，是因为我时常在想，如果带我、培训我的人是他，比起和办事处这位更年期妇女共事，我会不会能坚持把这份工作做下去？至于我为什么不主动提出去总部发展，这里就不展开说了，经过现实考量和自我盘问，觉得不合适就没去了。</li></ol><hr><p>「斯是陋室，唯吾德馨」，重点不在于陋室这个环境，而在于德馨的人。所以说到底，做什么工作和工作环境如何其实都是其次的，跟什么人相处共事才是很大程度上决定你能走多远。前面提到，我的领导是个五六十岁更年期的女强人，她是我们这个区域的经理，我每天都要和她打交道，她除了我前面提到的会把我当成从山里出来的野人以外，她还非常 <strong>双标</strong> ，这是我后面在和她儿子交接工作的时候发现的。没错，和她儿子交接工作，你看，这是不是越来越有意思了，且听我道来：</p><ol><li>有那么一个下午，经理叫我去楼下的肯德基买下午茶，我在自提回到办公室打开包装后，经理和我发现漏装了一个蛋挞（具体是蛋挞还是鸡翅之类的我给忘了），随后经理便开始长篇大论地给我讲道理了，说什么「做什么事都要细心」、「把工作当成自己的工作」、「不能依赖别人」之类的巴拉巴拉说了一大堆。我当时其实挺郁闷的，你本身就是打包的食物，正常人谁会特地去在工作人员封口前或者封口后打开包装确认有没有漏装然后再离店呢？正常人谁会这样？好，你讲的道理，我认可了，但是你有必要因此给我啰里啰唆半个多小时吗？你是真的没事干吗？这种事情一两句话带过就行了，你一口气讲了半个小时是怎样？难不成把我当成野人来教训会让你很有成就感？几个月后，我准备要离职了，他儿子过来交接工作。然后同样是在某个下午，同样是去肯德基打包下午茶，但是这次不同的是，取餐时是我和他儿子两个人一起到店去取的。取完餐回到办公室打开一看——巧了！又漏装了，这次漏装的还是一个汉堡。结果这一次，她竟然就只是对着她儿子说了一句话，说是之前我下去打包的时候也漏装过，然后就结束了。我他妈真是笑了，你不打算把之前对我讲的那些话拿出来对你儿子也讲一遍吗？为什么不呢？这不是你儿子吗？你不应该加大力度教育吗？还是说我取餐遇到工作人员漏装就是我的错，你儿子取餐遇到工作人员漏装就是工作人员的错呢？如此双标？至于她为什么不敢教训她儿子，在经历了后面的某件事之后，我想我也知道答案了。交接工作的某天下午，我和她儿子出差在外，路上她儿子在用电话向她汇报工作情况，说是我们计划再去拜访一家客户后就启程返回，汇报完了还多说了一句生病不舒服，然后她就挂了她儿子的电话，原因是她觉得她昨晚叫他吃药，但是他没吃，今天要工作了，就拿身体不舒服来说事。结果她儿子因为被挂电话就非常不爽，火冒三丈大发雷霆，立刻打电话回去把她臭骂了一顿，我在旁边听得真是乐死了。挂了电话，在去客户公司的路上，她儿子还一直在对着我说他妈的不是，以此解气。他说她这样的态度让他很难接受，他虽然说是不舒服，但是也没说不工作，他觉得他妈挂他电话让他很来火。最后从客户那里回来后，我还陪她儿子去打台球（果然公子哥有夜生活就是不一样），她后面还发微信问我她儿子还生不生气，着实是让我开了眼界。所以你现在知道为什么她不敢说她儿子了吗？因为她儿子很有可能会屌她飞起来。笑死。说我的时候倒是毫无心理负担啊，越说越来劲，说出了成就感，说出了优越感，说出了自信。</li><li>第二个例子是在和她儿子交接工作的某一天上午，我们准备要出差去见客户，临走前她竟然跟我说，如果她儿子开车累了，就让我帮开一会儿，别让他太累。我他妈真是无语了，我寻思你儿子去见客户走的这条逼路和我去见客户走的不是同一条吗？那我每次往返这条路都是自己一个人开的，怎么你儿子就不能自己一个人开吗？怎么他妈的到他开车你就要考虑他累不累，我开车的时候怎么他妈的不见你问过我累不累呢？你儿子开的还是小鹏的旗舰级轿车顶配的小鹏 P7i 啊，我开的还是他妈公司跑业务用的小鹏 G3 呢？双标不要太明显吧姐姐？你儿子就是儿子，人家儿子就不是儿子是吧？着实是让我开了眼界。</li><li>第三个例子。我这个岗位有一个工作专用的微信号，她告诉我要时不时发发朋友圈，如果不知道发什么，那就把总部老板的朋友圈发的内容复制粘贴过来发。这一点倒是没错，毕竟销售就是要刷存在感。在我任职期间，虽然数量不多，但也算是有发几条，其中有【自己出差路途中拍的风景照 + 产品照片 + 网络文案】的组合，也有纯粹的【产品照片 + 广告语】的组合。但是自从我 2023 年 10 月 18 日离开，她儿子接手工作后，这个微信就压根没更新过朋友圈。我他妈真是迷惑了，就连总部老板都需要经常发朋友圈，怎么她儿子的销售技巧是有多高超，连朋友圈都可以不用发？我在的时候就老叫我发，到她儿子了她就不管了，如此双标着实是让我开了眼界。</li><li>第四个例子。在我任职期间，有那么几次，当我的工作让她不满意的时候，她甚至连我平时用的数码设备都要拿出来说。她说我既然有那么好的手机（iPhone 14 Pro Max）和电脑（MacBook Air 2020 M1），就应该把它们好好用在工作上。我他妈真是吐了，我寻思你说工作就说工作，为什么要把范围蔓延到我的数码产品上呢？我之前是敲代码的，再加上我自己又喜欢这类产品，有几台好设备有什么问题吗？这你都能喷？你怎么不去看看你那败家子用的是什么设备啊？我反正是有幸进过她儿子的房间：桌面上摆的是 MacBook Pro 外接一台 LG 显示器，然后还有 Xbox Series X 、Switch 、Keychron 键盘，手上也拿着 14PM ，甚至还有一台 Xs ，然后车开的是小鹏 P7i 。所以你怎么不说说你儿子，让他把这些东西都用到工作上呢？噢我忘了，你是双标狗，那没事了。而且说到底，这些设备只要在工作上能派上用场，谁会不用来工作啊？难道你买一台手机是要放在家里当传家宝吗？你说这些话也着实是让我开了眼界。</li></ol><p>说到她儿子就更是重量级，应该比我大两岁，但是整个人给我的感觉就像 18 岁时的我一样，工作还没开始做就大放厥词，把牛皮吹上天。当时他知道我要走了，他妈又临时招不到人或者是不想招了，某天下午就请我喝了杯瑞幸咖啡然后跟我大谈人生理想，说什么人要有远见，要有格局之类的有的没的。哥们儿，我要是像你一样也是独生子，我家要是跟你家一样有钱，我要是也能去澳洲读个本科随便花个百来万人民币的话，我就也可以像你一样在别人面前谈格局你懂吗？说了半天始终扯不到实干上，你就比我大两岁，你还真把自己当成那种四五十岁见过世间百态、身经百战，视职场如战场的成功人士一样啊？这么说吧，咱们都是同龄人，每一代人都有每一代人的毛病，我身上有的问题，你也跑不掉。更何况你家还有点小钱，你还是独生子，你这种娇生惯养的公子哥真以为自己成长到哪去了？吹牛谁不会啊？你要真想让自己看起来成熟一点，那就把你那路怒症改改吧。是的，这傻子还有路怒症，就是开车的时候喜欢骂别人，而且很频繁，跟他一起出差经常给我整得很无语。我寻思这样做有什么意义呢？你牛逼你就直接下车去跟别人当面对峙啊，你在车上骂他，他又听不见，反而搞得车上的人心烦意乱，并且显得你很幼稚你知道吗？最后再说一下他之前在跟我「喝咖啡论英雄」时说的几个非常经典的言论：</p><ol><li>他说：他本科读的这个专业，回国随便都能找一份月薪过万的工作。我不知道怎么回复。</li><li>他说：这份工作（也就是我正在干的这个销售业务员的岗位）他要是想干，是可以干的很好的。我他妈当时差点没把嘴里的咖啡喷出来。不是，哥们儿，我要是想干，我也能干啊，问题就是我不想干啊！</li><li>他还说：他要是想干，他还可以把他同学叫过来一起干，一起把这个事业做大，并且还要利用好他前一份工作的客户名单，好好拓展业务。我倒不是怀疑他，毕竟交接工作的这段时间他经常当着我的面给他那好基友打电话聊天，期间就有提到要不要一起做这个工作，但最后也没看到有什么结果。</li></ol><p>对于他的这些言论，我只能说确实牛逼，原来这就是格局，这就是境界。但是又有一点让我很费解，他说了那么多，然后在 2023 年 10 月 18 日接手我的工作后，在 2024 年的 2 月份就跑路不干了是什么意思呢？你知道我憋笑有多难受吗？不是哥们儿，吹牛这一块，说一套做一套这一块，还得是你啊。说什么拿客户名单来拓展业务，说什么找兄弟过来一起帮忙，哥俩一起创业，打造自己的事业，结果到头来干几个月人不见了？着实是让我开了眼界。所以我为什么说他虽然比我大两岁，但是整个人给我的感觉就像 18 岁时的我一样，什么事情都是先说在做，或者说了不做，搞得好像你说了你就能做到一样，真他妈幼稚……不对，仔细想想，我 18 岁时也没他这么傻逼吧，严谨地说，他现在的样子应该对应的是我 13 岁到 16 岁时的样子吧。</p><p>说回工作，在我上岗之前，我就已经从准备要跑路的前辈那了解到，他当时上岗，也是因为当时在岗的人要跑路了。也就是说，在我之前，已知的已经有两个人跑路了，而且他们干的时间都不长。然后当我在 2023 年 10 月 18 日跑路后，经理的儿子上来也没干多久，到 2024 年的 2 月份也跑路了，紧接着又来了个姓何的，干了两个月也跑路了。我为什么在离开后还能了解到这些人事变动，那是因为我的私人微信里还留着之前的工作微信，又因为工作微信的名字是「公司名称 + 业务员名字」的格式，所以只要业务员的名字变了，就可以知道这个岗位又换人了。就连我在职时，我们的客户都经常问我说为什么我们的人事变动这么频繁，我想现在大家都知道原因了。再后来，某一天我发现工作微信的名字格式已经变成了「公司名称 + XX办事处」，我猜测要么是没招到新人，要么就是人事变动过于频繁，为了不要让客户看到这个岗位总是在换人，太丢人了，索性就改成了现在这样。不过要是真换人了，微信名字改不改其实也都掩盖不住事实，到时候出差拜访客户，客户自然会察觉怎么这次来的业务员又和上次来的不是同一个人……无所谓了，反正我笑话是看够了。</p><hr><p>最后再说说我自己的感受吧，我也知道一份工作不可能百分之百让人满意，哪怕是当小姐都要应对各种各样的客人，在工作中遇到问题，无非就是以一个什么样的心态来面对而已。对于这份工作，大部分时候给我的感觉就像是坐牢，没有一丝一毫的正反馈，从头到尾让我毫无兴致，最重要的是，干的又累又多，给的钱却不多。但是如果让我回来当码农呢，虽然在工作中也会遇到很难实现的需求或者是很难解决的 BUG ，但是钻研技术本身或者是学习知识的过程就会让我乐在其中。所以兴趣还是很重要的，如果对一件事情感兴趣，那么再多的投入也值得，非常简单的道理。当然这几个月下来我也不是毫无收获，除了对这个行业有了些许了解以外，我也在待人处事上有了一点长进，所以说了那么多领导的坏话，到最后我还是要感谢她这几个月来的教导。再不济地说，这几个月上班的工资不仅能让我活下去，还可以让我买一些愿望单上的东西。那么这个工作就没有一点好处吗？也许有吧，只不过在掂量一番过后我还是选择了离开，就说明它的好处目前还远不及我在那个位置上所受的痛苦。</p><p>总之，这半年来的回顾大概就是这样了。本篇文章首次发布的时间是 2023 年的 11 月份，后面或许还会回来补充一些想法和细节。回顾今年一整年，发现今年的历程和去年真的很像，都是过完年大概 2 月底这样从家里出来工作，然后同样是九月份十月份这样失去了工作然后无所事事最后回家等过年。或许真如老爸所说，我并不适合出来大城市闯荡吧。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>看门狗：军团 - 测评</title>
    <link href="/posts/Review-Watch-Dogs-Legion/"/>
    <url>/posts/Review-Watch-Dogs-Legion/</url>
    
    <content type="html"><![CDATA[<p>只需要差不多 35 个小时，就可以把看门狗军团的主章节和「血脉相承」DLC 的主线任务以及必要的支线任务体验完。</p><span id="more"></span><p>这款由多伦多工作室开发的甚至都不敢命名为「3」让其成为正统续作的看门狗系列作品，给我的感觉确实比较一般，至少剧情很一般。我自己玩的时候，也只需要前 10 个小时，就可以把所有新鲜的东西都体验完了，剩下的就是育碧开放世界公式里的常规操作，说实话，这些消磨时间的重复行为让我在玩的时候会有点反胃的感觉。</p><h2 id="主章节"><a href="#主章节" class="headerlink" title="主章节"></a>主章节</h2><p>这一作主打的「无主角」玩法也没有想象中或者是宣传中的那么亮眼，实际表现就好像 2077 发售前后的对比一样。一轮体验下来，这个「无主角」真的可以说是可有可无的存在，因为育碧只不过是把本来应该是一个人所掌握的技能分散到好几个人身上去了，然后你为了使用这些技能，你不得已需要通过「招募」去让这些角色加入组织，然后切换到这个角色，才能使用这个角色的技能。但是当你在操作这个角色的时候，显而易见的，你又不能使用其它角色的技能了……然后所谓的「招募」其实也就是让你去帮 NPC 做一个内容类似于游戏里支线的任务，然后完成任务后，NPC 为了报答你就会加入 DedSec ，说到底又是一个消磨时间的操作。</p><p>至于为什么要加入这样的玩法，我觉得是因为通过前两部作品，让玩家认识到了 DedSec 是一个怎样的组织，以及平时会干什么。但是组织是怎么扩充人手的，却从来没有相关介绍和玩法，所以策划可能会觉得「噢，把其他人招募进 DedSec 或许是个不错的 idea 」，然后「招募」系统就应运而生了，然后顺势而然地就诞生了接下来的「无主角」玩法。只能说这就是图个新鲜，算是个不能说加分但至少不扣分的玩法。说到底技术上的限制根本不可能让一款游戏拥有无数个结局，也许过程不一样，但结局都是一样的，最多最多像尼尔那样给你搞好几个不同分支的结局已经很了不起了。而且就是因为「无主角」的加入，导致这游戏的角色刻画真的可以说是前所未有的差劲！这游戏根本没有一个可以让你印象深刻的角色，艾登？克拉拉？马库斯？扳手？没有！和前两作相比，我真的记不住这一作中任何人的名字，而且我相信就算记住了，过了一两年后我也会忘记。</p><hr><p><img src="/../../images/ACGN/WatchDogsLegion.jpg" alt="下雨时的伦敦桥"></p><p>游戏设立在了近未来的伦敦，出现了更多种类的无人机，以及街上的所有车辆都可以完全自动驾驶，游戏中还多次利用了 AR 来推进任务，这些设定都很符合我们对未来的想象。而且伦敦怎么说也是个知名的大城市，拥有伦敦桥这样和旧金山金门大桥类似的知名景点，这样的城市用来作为新游戏的背景再适合不过了。但无论怎么样都无法改变其它地方很拉跨的事实，就像水桶效应一样，背景设定也许是最高的那一块木板，但是并不能保证能装满一桶水。</p><hr><p>游戏的建模也是，重复的脸模真的很多，所有的女性脸模可能用十个手指头都数得过来。所以如果想要构造不同的人物形象，就得靠穿搭和服装。但是游戏里的服饰设计又没什么很大的差异化，搞得我连买衣服的欲望都没有，买衣服用的货币存了一堆<del>（能不能兑成人民币啊）</del>。</p><hr><p>游戏里的车载音乐也非常糟糕，我真的无法想象都 2020 年了还有车载音乐这么拉跨的都市开放世界游戏。一代和二代，甚至是十年前的 GTA 5 ，随便拉一个出来都能挑出几首我喜欢的歌曲，军团真的是他妈的一首都没有啊！你一上车，它会给你放那些好像有点古典感觉的纯音乐，好像还有 FM ，以及流行音乐，但是无论放什么，声音都很小，基本听不清在唱什么。然后也许是因为制作人自己也知道车载音乐拉跨，所以才制作了地铁系统，用来快速在各个地方移动，省去了你跑图的功夫。但是说实话，适当地跑图也是游戏体验的一部分。甚至有没有一种玩法，就是我已经把任务都做完了，但是就是舍不得离开伦敦，然后时不时想回来开车听音乐兜兜风？但是你这车载音乐真的让我想吐。</p><p>既然说到车载音乐，就顺便提一下车辆的驾驶体验。同样的，不能说加分，只能说是不扣分。车辆在伦敦街道上的行驶感觉非常平滑，没有什么高低差很大的地方以至于让车辆起飞。漂移也很好掌握，只需要稍加练习就可以不用在过弯的时候刻意减速了。路上的护栏和路灯感觉很「轻」，都可以被随意撞掉，对驾驶不会有太大的影响。</p><hr><p>前面提到不同的角色有不同的技能，实际上不同的角色可以使用的武器种类也是不一样的。在本作中，制作组似乎更加重视「不杀人通关」了，再加上我记得他们曾经提到过伦敦不像在美国这么容易能搞到枪。所以游戏中大部分角色使用的都是电击枪这样的非致命武器，只有特定职业或者身份的角色才能使用致命武器。其实非致命也没什么，但是你效率太低就不行了啊，打不倒人反而让对方触发了警报，那岂不是自找苦吃？而且这一作是没有狙击枪这一类武器的，一代就有。</p><h2 id="血脉相承"><a href="#血脉相承" class="headerlink" title="血脉相承"></a>血脉相承</h2><p>这是在游戏本体发售 8 个月左右才推出的 DLC ，我很愿意相信这是制作组因为本体的表现不佳然后赶工出来的补救措施。这种补救措施给我的感觉就好像是 2077 的后续补丁一样，也可以类比成《幽灵行动：断点》后面让 AI 重新回归一样……因为游戏本体的销量和风评真的太差了。简而言之，这个 DLC 就是育碧打的感情牌，让一代的老大哥艾登和二代中大家都很喜欢的扳手来救场。这让我想起一句话，当什么东西在走感情路线的时候，就代表它所剩的价值不多了。</p><p>说回 DLC 本身，剧情这里就不多评价了，育碧早都忘记怎么讲故事了，一代剧情的感人程度和艾登的形象刻画是无法复刻的。这一作中的艾登已经年过半百了，但制作组还是请回了原来的声优，以及为艾登保留了最经典的服饰，私法制裁者的感觉、Fox 的感觉，一下子就回来了——一部分。</p><p><img src="/../../images/ACGN/WatchDogsLegion-Aiden.jpg" alt="艾登"></p><p>DLC 的故事发生在主章节之前，游戏地图仍然是主章节的地图，也就是伦敦，只不过少了「招募」系统。而且随着主线的推进，玩家操作的角色会从艾登变为扳手，到最后完成所有主线后，就可以自由在艾登和扳手之间切换。又因为可操作角色缩减为了两人，所以需要考虑的东西也就少了，两人之间的技能差异化就可以做得足够大。所以其实 DLC 只有 5 个小时的游玩时间，但是整体体验真的会比主章节好。</p><p>虽然没了「招募」系统，但是并不代表育碧不会恶心你——没错，部分技能如果想要解锁，还是需要通过做支线任务。而且有几个支线任务是强制绑定在主线中的，我真的绷不住了，这就是我所说的想吐的感觉。</p><p>说到这里，不知道你会不会觉得一切都很熟悉，是的，如果育碧能把 DLC 的长度拉得跟主章节一样长，然后在剧情处理上再加点深度，加点反转，把矛盾扩大，最后再升华一下，这部作品完全可以命名为「看门狗 3」然后发布，完全没必要弄什么「招募」系统和什么「无主角」玩法。包括艾登为什么会从芝加哥来到伦敦，剧情开头都已经解释了，甚至就连这个 DLC 的名字都有所体现，什么叫「血脉相承」啊？只有亲人间才会有血脉相承啊，才会有这样的感情啊，为什么杰克森一开始对待艾登的态度那么冷漠？甚至都不愿意叫一声舅舅？亲人之间为什么会发生这样的矛盾？这才是大家想看的东西，而不是什么傻逼招募和无主角！我真的绷不住了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单来说，我可能会重玩一代和二代，但是我绝对不会重玩军团。一代是一个悲剧，二代是一个喜剧，军团是一个闹剧。一代让我感受到了艾登的人格魅力还有那种孤独的感觉，二代让我领悟到了团队和友情。军团给我带来了什么？我不想评价。</p><p>育碧，说真的，趁着艾登的声优还能继续配音，实在不行咱们把一代重置一下，在剧情上增加一条克拉拉没死的线行吗？你出了我必买单，别整天整这些花里胡哨的了。</p><p><img src="/../../images/ACGN/WatchDogsLegion-Wrench.jpg" alt="扳手"></p>]]></content>
    
    
    <categories>
      
      <category>ACGN</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2023 年 4 月 2 日</title>
    <link href="/posts/2023-04-02/"/>
    <url>/posts/2023-04-02/</url>
    
    <content type="html"><![CDATA[<p>今天连续玩了五个半小时，把 Subverse 最近的两个主线更新体验完了。</p><span id="more"></span><p>先来看一下主线的更新时间：</p><ul><li>SOVA 的主线故事（Version 0.5.0 STORY UPDATE (7&#x2F;25&#x2F;22)）</li><li>FORTUNE 的主线故事（Version 0.6.0 STORY UPDATE (12&#x2F;19&#x2F;22)），距上次更新过去了五个月</li><li>HUNTRESS 的主线故事（Version 0.7.0 STORY UPDATE (3&#x2F;27&#x2F;23)），距上次更新过去了三个月</li></ul><p>刚好周末，就打算把 FORTUNE 和 HUNTRESS 更新的内容体验一下。</p><h2 id="FORTUNE"><a href="#FORTUNE" class="headerlink" title="FORTUNE"></a>FORTUNE</h2><p>之前之所以一直没推进 FORTUNE 的剧情是因为我不太喜欢这个角色，如果用下体来解释，就是因为她不够戳我的性癖，因为我还是更喜欢像 LILY 和 KILLI 那样的御姐。但是经过我今天在主线剧情中与她的接触，我突然发觉她也还是个不错的女孩儿。如果用大脑来解释，那就是她的性格和能力吸引了我：「年纪轻轻就是一名就拥有高超技巧的黑客，为了大家能够按自己的方式生活而奋起反抗 Imperium 。」剧情中也提到了她的出身，以及是谁把她养大的，或许就是这样与众不同的经历，才造就了今天的她，就是因为这样的她，才会深受大家喜爱。之前在 Twitter 上看到大家都在催更 FORTUNE 主线的时候我还不是很理解，但是现在我只想说「马头社你做得好啊。」</p><h2 id="HUNTRESS"><a href="#HUNTRESS" class="headerlink" title="HUNTRESS"></a>HUNTRESS</h2><p>HUNTRESS 作为一名频繁来找我们麻烦的赏金猎人，对于她到底能不能被攻略，剧情到底要怎么反转，我还挺期待的。虽然这样的游戏不需要太过在意剧情的合理性（就像日本少年热血漫画一样），但是马头社还是交出了不错的答卷。具体来说就是利用了「种族文化」的设定，再具体一点来说就是在剧情中，舰长一行人和 HUNTRESS 进行了两次决斗，两次都赢了，并且两次都选择 spared her life ，这样的 mercy 对她的种族来说是需要以身相许的哈哈哈哈。可以说真的是很烂的套路，但是大家都很喜欢，至少我很喜欢，这样的结局和设定真的很合适哈哈哈哈。</p><h2 id="我射爆了"><a href="#我射爆了" class="headerlink" title="我射爆了"></a>我射爆了</h2><p>这两次更新不仅有能让我们认识两位颇具魅力的美人儿的有趣剧情，更带来了实用性一如既往的高的潘多拉场景。此话怎讲？我在昨晚冲了一次的情况下，今天还能靠这些动画在一天之内又冲了两次……值得一提的是这两位角色的招募 scene 之前有一小段过场动画，这段过场动画在剧情对话和开始本番之间做了一个很好的过渡，让玩家更好地代入进去。我记得之前的角色好像是没有这样的动画的。总之这个过渡真的很加分，彷佛 FORTUNE 就是我亲手抱上床的，然后 HUNTRESS 真的是在和我互动一样。</p><p>此外通过剧情，我还感觉到 FORTUNE 和 HUNTRESS 这两位比起前面的角色来说会更“守规矩”，通俗来说就是不会乱搞。FORTUNE 的出身和她的成长环境以及她的理想让我感觉她顶多就是自己解决的情况多一些。而 HUNTRESS 的话她自己也说了，再找到自己的 equal 前是不会 mate 的。只能说这样的设定真让纯爱战士狂喜。</p><h2 id="展现真正的技术"><a href="#展现真正的技术" class="headerlink" title="展现真正的技术"></a>展现真正的技术</h2><p>说实话战棋玩法的规则我不是很懂，太空战斗也是真的对手残党很不友好（尤其是今天玩的时候，明显感觉到整体难度提升了好多），所以刚开始玩这游戏的时候经常血压飙升。但是说到底这是个单机游戏，作为一个本科专业是软件工程的码农，不应该被单机游戏搞得如此狼狈，所谓技术不够科技来凑。打开 WeMod ，直接启用无限生命无限能量——让一个需要技巧的游戏瞬间变成了割草游戏，这下舒服了。</p><p>不过虽然通关变得轻松了，但是想要获得只有通过提升角色的 devotion 才能获得的用来解锁潘多拉场景的点数，还是需要频繁地刷副本……这下就不得不请出老朋友 Cheat Engine 了，经典的内存扫描和内存修改哈哈。</p><p>提到 Cheat Engine ，就让我想起前段时间看到的一个用 Cheat Engine 修改百度网盘下载速度的视频，着实是够抽象的了。还有就是用 Cheat Engine 来修改《卧龙：苍天陨落》捏脸时女性角色的胸部大小参数，尽管这个参数的值在游戏中有上限，但是依然可以在 Cheat Engine 里将其设置为超过上限的大小，并且游戏还是会应用设置后的值，结果就会让女角色的胸变得超大哈哈。</p><h2 id="后续呢"><a href="#后续呢" class="headerlink" title="后续呢"></a>后续呢</h2><p>到现在为止，仍然未被攻略的女角色至少有 3 个，一个是之前的上司吧，另外两个都是帝国那边的角色，其中一个是老阿姨 KASIDORA （老太婆了我感觉其实），还有一个是也是非常戳我性癖的 CELESTINA（182 cm 的身高我真的爱了家人们谁懂啊）。不过刚才特地到官网看了一下，还有一个女角色是一直记录在案并且也决定了声优但是一直未在游戏中露面的 FOWCHAN ，不知道下一次的更新会不会登场。</p><p>总而言之，真的很享受这两次更新的内容，同时也很期待下次的更新。唯一的问题就在于游戏目前还没有中文字幕，以目前的英文水平，在读完剧情后，对故事的来龙去脉依旧云里雾里。个人感觉主要还是因为他们用了很多俚语或者网络用语，以及语法过于口语化。当然个人的词汇量不足也是个问题，比如有时候出现了某个我认识的单词的变体（变形容词、变否定形式），一时间我还没看出来，然后一查词一看词根才发现：「噢，原来是它啊」……</p><p>英语作为核心出装还是太重要了。</p><p><img src="/../../images/ACGN/allMyWaifus.jpg" alt="All my waifus"></p>]]></content>
    
    
    <categories>
      
      <category>ACGN</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin 学习笔记 - 基础</title>
    <link href="/posts/Kotlin-study-notes-basic-part/"/>
    <url>/posts/Kotlin-study-notes-basic-part/</url>
    
    <content type="html"><![CDATA[<p>这篇笔记是对 Kotlin 的基础语法和一些基本特性进行记录。</p><span id="more"></span><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>在 Java 中存在 8 个基本数据类型以及相对应的包装类。</p><ul><li>int(整型) -&gt; Integer</li><li>short(短整) -&gt; Short</li><li>long(长整) -&gt; Long</li><li>float(单精度浮点) -&gt; Float</li><li>double(双精度浮点) -&gt; Double</li><li>char(字符) -&gt; Character</li><li>byte(字节) -&gt; Byte</li><li>boolean(布尔) -&gt; Boolean</li></ul><p>例如<code>int</code>一般用于修饰变量，而<code>Integer</code>则是作为一个类存在的，拥有自己的成员变量和成员函数。Java 这么做是为了降低开销，提升性能，而在 Kotlin 中，则不存在基本数据类型，例如整型直接对应的就是<code>Int</code>这个类。</p><p>在 Kotlin 中存在诸如<code>toByte()</code>、<code>toFloat()</code>、<code>toString()</code>等类型转换函数用于更好地转换类型。</p><p>Kotlin 中的字符串也有很多实用的功能，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 利用字符串模板在字符串中直接加入变量</span><br><span class="hljs-keyword">val</span> name = <span class="hljs-string">&quot;Aiden&quot;</span><br>println(<span class="hljs-string">&quot;name is <span class="hljs-variable">$name</span>, and length of the name is <span class="hljs-subst">$&#123;name.length&#125;</span>.&quot;</span>)<br><br><span class="hljs-comment">// 以所见即所得的形式定义一个字符串</span><br><span class="hljs-keyword">val</span> s = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    haha</span><br><span class="hljs-string">    h e he</span><br><span class="hljs-string">&quot;&quot;&quot;</span>.trimIndent()<br>println(s)<br></code></pre></td></tr></table></figure><p>输出结果为：</p><blockquote><p>name is Aiden, and length of the name is 5.<br>haha<br>h e he</p></blockquote><h3 id="空安全"><a href="#空安全" class="headerlink" title="空安全"></a>空安全</h3><p>假设在 Java 中定义了一个<code>Person</code>类，然后去实例化它的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>这么写是没错的，变量<code>person</code>就是<code>Person</code>类型的，只不过它的值为<code>null</code>而已。照着这个思路，在 Kotlin 中会很自然地写出：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> p: Person = <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>这时候编译器会报错：<code>null</code>不可以被赋值给一个值不能为<code>null</code>的类型。也就是说，变量<code>person</code>确实是<code>Person</code>类的实例，只不过它不能被赋值为<code>null</code>，如果想要把它赋值为<code>null</code>，需要把它的类型改成<code>Person?</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> p: Person? = <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>而当调用一个可为空类型的对象的时候，编译器会报错并提供 3 种更加安全的方案：</p><ul><li>添加空检查：使用 if 语句判断对象是否为<code>null</code>，在不为<code>null</code>的分支中执行代码。</li><li>使用安全调用：例如<code>person?.walk()</code>，这样一来当<code>person</code>为<code>null</code>时它将不会调用<code>walk()</code>。</li><li>使用非空断言：例如<code>person!!.walk()</code>，此举将告知编译器<code>person</code>不会为空，如果为空，后果自负。</li></ul><p>Kotlin 的这些特性使得所有对象在默认情况下都不能为<code>null</code>，以及在一定程度上避免了出现空指针异常的情况。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数的命名和变量一样都是小驼峰式命名法，也就是以小写字母开头。</p><h3 id="单一表达式函数"><a href="#单一表达式函数" class="headerlink" title="单一表达式函数"></a>单一表达式函数</h3><p>针对只有一条 return 语句的函数，可以直接用<code>=</code>连接函数名，后面跟上返回的内容，这样就省去了花括号和返回类型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(name: <span class="hljs-type">String</span>)</span></span> = <span class="hljs-string">&quot;Hello, <span class="hljs-variable">$name</span>&quot;</span><br></code></pre></td></tr></table></figure><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>Kotlin 函数中的参数支持设置默认值，这使得函数在调用时会更灵活：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(name: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;Aiden&quot;</span>)</span></span> = <span class="hljs-string">&quot;Hello, <span class="hljs-variable">$name</span>&quot;</span><br></code></pre></td></tr></table></figure><p>此时如果调用<code>sayHello()</code>不传入参数的话，那么<code>name</code>的值将会是<code>Aiden</code>。</p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>Kotlin 中的 if 语句不仅可以作为 Statement 使用，还可以作为 Expression 使用。例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> age = <span class="hljs-number">18</span><br><span class="hljs-keyword">val</span> isAdult = <span class="hljs-keyword">if</span> (age &gt;= <span class="hljs-number">18</span>) <span class="hljs-literal">true</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">false</span>  <span class="hljs-comment">// 直接对 isAdult 进行赋值</span><br></code></pre></td></tr></table></figure><h3 id="when"><a href="#when" class="headerlink" title="when"></a>when</h3><p>简而言之就是 Java 中的 switch 语句，只不过同样可以当 Expression 使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> score = <span class="hljs-number">80</span><br><span class="hljs-keyword">val</span> level = <span class="hljs-keyword">when</span> (score) &#123;<br>    <span class="hljs-number">80</span> -&gt; <span class="hljs-string">&quot;High&quot;</span><br>    <span class="hljs-number">60</span> -&gt; <span class="hljs-string">&quot;Medium&quot;</span><br>    <span class="hljs-keyword">else</span> -&gt; <span class="hljs-string">&quot;Low&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>不过与 switch 不一样的是 when 强制要求添加<code>else</code>分支。</p><h3 id="while-for"><a href="#while-for" class="headerlink" title="while &amp; for"></a>while &amp; for</h3><p>Kotlin 中的 while 语句和 Java 的没什么区别，就是循环，但是 for 语句更多的起到一个遍历的用途。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 遍历数字区间</span><br><span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.5</span>)  <span class="hljs-comment">// 左闭右闭区间 [1, 5]</span><br>    println(i)<br><br><span class="hljs-comment">// 倒序遍历数字区间</span><br><span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">5</span> downTo <span class="hljs-number">1</span>)  <span class="hljs-comment">// 不能使用 5..1</span><br>    println(i)<br><br><span class="hljs-comment">// 遍历列表</span><br><span class="hljs-keyword">val</span> stringList = listOf(<span class="hljs-string">&quot;Aiden&quot;</span>, <span class="hljs-string">&quot;Marcus&quot;</span>, <span class="hljs-string">&quot;WatchDogs&quot;</span>)<br><span class="hljs-keyword">for</span> (str <span class="hljs-keyword">in</span> stringList)<br>    println(str)<br></code></pre></td></tr></table></figure><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="普通类"><a href="#普通类" class="headerlink" title="普通类"></a>普通类</h3><p>假设要定义一个「人」类，拥有姓名和年龄这两个属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span>)<br></code></pre></td></tr></table></figure><p>这一行代码中包含了很多信息：</p><ul><li>类名后面的括号实际上是主构造函数，在实例化对象的时候会把传进来的参数（上述例子中是<code>name</code>和<code>age</code>）赋值给类中的属性。</li><li>括号内定义的是类的属性，同时编译器还会为这些属性生成 getter 和 setter 函数。只不过用<code>val</code>修饰的变量就只会有 getter 不会有 setter ，因为<code>val</code>修饰的属性是不可修改的，而<code>var</code>修饰的则两者都有。</li></ul><h3 id="自定义-getter-setter"><a href="#自定义-getter-setter" class="headerlink" title="自定义 getter setter"></a>自定义 getter setter</h3><p>无论是 Java 还是 Kotlin 的属性都会有 getter 和 setter 函数，但是 Kotlin 的属性还拥有自定义 getter 和 setter 这个特性。假设现在要为上面的<code>Person</code>类增加一个叫做<code>isAdult</code>的属性，获取这个属性的时候返回一个布尔值，如果是<code>true</code>就代表这个对象已经成年了，可以这么做：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    Person(<span class="hljs-string">&quot;Aiden&quot;</span>, <span class="hljs-number">23</span>).also &#123;<br>        <span class="hljs-keyword">if</span> (it.isAdult) println(<span class="hljs-string">&quot;成年了&quot;</span>)<br>        <span class="hljs-keyword">else</span> println(<span class="hljs-string">&quot;未成年&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span>) &#123;<br>    <span class="hljs-keyword">val</span> isAdult<br>        <span class="hljs-keyword">get</span>() = age &gt;= <span class="hljs-number">18</span><br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为：</p><blockquote><p>成年了</p></blockquote><p>可以看到：</p><ul><li>成年与否实际上应该算是一个人的属性而不是函数，只有像走路、吃饭这样的事情才应该写成函数，这是很符合直觉的。</li><li><code>get()</code>直接用<code>=</code>连接这种写法同样是用到了之前说到的单一表达式函数特性，但是如果 getter 的逻辑一行写不完，那也可以用花括号而不是直接用等号。</li><li>从语法的角度来看，确实增加了一个新的属性<code>isAdult</code>。但是从实现层面来看，编译器在 JVM 层面仍然将其优化成了一个函数，所以这个「属性」并不会占用内存。</li></ul><p>被<code>var</code>修饰的属性就会有 setter ，只不过如果希望在实例化对象的时候额外做点事情，那么就可以使用自定义 setter ：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-keyword">val</span> name: String) &#123;<br>    <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">set</span>(value) &#123;<br>            println(<span class="hljs-string">&quot;do something.&quot;</span>)<br>            field = value<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到：</p><ul><li><code>age</code>仍然是被<code>var</code>修饰，代表它有 setter 函数。</li><li>想要为<code>age</code>增加自定义 setter ，需要将其从主构造函数中分离出来，并且为其初始化。</li><li>例如<code>person.age = 23</code>这条语句，<code>23</code>会在自定义 setter 中作为参数被传递，也就是<code>set(value)</code>中的<code>value</code>，而函数体内的<code>field</code>代表的是<code>age</code>本身的值，这里是<code>0</code>，因为初始化为<code>0</code>。</li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>Kotlin 在类继承方面仍然有很多新特性：</p><ul><li>Java 继承使用<code>extends</code>关键字，Kotlin 使用冒号<code>:</code>，继承类使用冒号，实现接口也使用冒号，类和多个接口之间用逗号<code>,</code>分离。</li><li>Java 重写函数用<code>@Override</code>注解，Kotlin 使用<code>override</code>关键字修饰重写的函数。</li><li>Kotlin 的类默认是不能被继承的，只有被<code>open</code>关键字修饰的类才能被继承，同样只有被<code>open</code>关键字修饰的函数才能被重写。</li></ul><h3 id="类嵌套"><a href="#类嵌套" class="headerlink" title="类嵌套"></a>类嵌套</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">val</span> name = <span class="hljs-string">&quot;Aiden&quot;</span><br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><span class="hljs-comment">//        val str = name  // 报错</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将<code>B</code>类嵌套在<code>A</code>类内部，内部类不能访问外部类的属性，这种情况对应了 Java 中的静态内部类。如果想要内部类可以持有外部类的引用，则需要给内部类加上<code>inner</code>关键字：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">val</span> name = <span class="hljs-string">&quot;Aiden&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">walk</span><span class="hljs-params">()</span></span> &#123;&#125;<br><br>    <span class="hljs-keyword">inner</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br>        <span class="hljs-keyword">val</span> str = name<br>        <span class="hljs-keyword">val</span> method = walk()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Kotlin 将类嵌套默认实现成静态内部类，这样在默认情况下就不会出现内存泄漏的情况。</p><h3 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h3><p>数据类（data class）主要是用于存放数据的类，是 Java 没有的概念。</p><ul><li>数据类的主构造函数中至少要有一个参数。</li><li>编译器会为数据类生成几个函数：N 个 componentN()，其中 N 代表主构造函数中参数的个数、<code>copy()</code>、<code>toString()</code>、<code>hashCode()</code>、<code>equals()</code></li></ul><h3 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h3><p>密封类（sealed class）类似于枚举，不过更强大。也是 Java 中没有的概念。</p><p>枚举中的一个值和它自己永远是的结构相等且引用相等，如果需要枚举的值拥有不一样的引用，就可以使用密封类。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul><li>接口中可以声明属性，只不过属性不能有初始值。被<code>val</code>修饰的属性可以自定义 getter ，被<code>var</code>修饰的属性既不能自定义 getter 也不能自定义 setter 。</li><li>函数也可以有默认实现。</li></ul><h2 id="编译器干了什么"><a href="#编译器干了什么" class="headerlink" title="编译器干了什么"></a>编译器干了什么</h2><h3 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h3><p>前面提到，相较 Java 来说，Kotlin 在语法层面是只有包装类的，也就是例如 Java 中的 long 到了 Kotlin 后就只有 Long 。但是原始类型的存在也是有理由的，因为它的性能损耗会更低，那么 Kotlin 是怎么优化性能的？</p><p>首先在 Kotlin 写出声明 Long 类型变量的一些情况：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 可变和不可变的 Long</span><br><span class="hljs-keyword">val</span> a = <span class="hljs-number">1L</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-number">2L</span><br><br><span class="hljs-comment">// 可变和不可变的、可为空但是并不是空的 Long</span><br><span class="hljs-keyword">val</span> c: <span class="hljs-built_in">Long</span>? = <span class="hljs-number">3L</span><br><span class="hljs-keyword">var</span> d: <span class="hljs-built_in">Long</span>? = <span class="hljs-number">4L</span><br><br><span class="hljs-comment">// 可变且可为空的 Long ，先赋为 null 再赋值为 5L</span><br><span class="hljs-keyword">var</span> f: <span class="hljs-built_in">Long</span>? = <span class="hljs-literal">null</span><br>f = <span class="hljs-number">5L</span><br><br><span class="hljs-comment">// 可变且可为空的 Long ，先赋为 6L 再赋值为 null</span><br><span class="hljs-keyword">var</span> g: <span class="hljs-built_in">Long</span>? = <span class="hljs-number">6L</span><br>g = <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>将其反编译为 Java ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br><span class="hljs-type">long</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2L</span>;<br><span class="hljs-type">long</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">3L</span>;<br><span class="hljs-type">long</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">4L</span>;<br><span class="hljs-type">Long</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>f = <span class="hljs-number">5L</span>;<br><span class="hljs-type">Long</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> <span class="hljs-number">6L</span>;<br>g = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>可以看到，尽管在 Kotlin 中只使用了 Long ，但是到了 Java 就变成既有 long 又有 Long 了，这背后的工作也是由 Kotlin 编译器完成的。一句话总结就是，有可能为<code>null</code>的数据，编译器会自动将其声明为包装类型。</p><h3 id="接口语法"><a href="#接口语法" class="headerlink" title="接口语法"></a>接口语法</h3><p>Kotlin 中的接口可以有属性，函数可以有默认实现，这是什么原理呢。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ClickListener</span> &#123;<br>    <span class="hljs-keyword">val</span> enable: <span class="hljs-built_in">Boolean</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">click</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;被点击了&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyButton</span> : <span class="hljs-type">ClickListener</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> enable: <span class="hljs-built_in">Boolean</span> = <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>先从接口的定义看起，有一个布尔类型的属性和一个函数，反编译至 Java ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ClickListener</span> &#123;<br>   <span class="hljs-type">boolean</span> <span class="hljs-title function_">getEnable</span><span class="hljs-params">()</span>;<br><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">click</span><span class="hljs-params">()</span>;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultImpls</span> &#123;<br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">click</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> ClickListener $<span class="hljs-built_in">this</span>)</span> &#123;<br>         <span class="hljs-type">String</span> <span class="hljs-variable">var1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;被点击了&quot;</span>;<br>         System.out.println(var1);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到：属性本质上是一个 get 函数，<code>click()</code>的默认实现被放到了一个静态内部类当中的一个同名静态函数当中。再来看<code>MyButton</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyButton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ClickListener</span> &#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> enable;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">getEnable</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.enable;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setEnable</span><span class="hljs-params">(<span class="hljs-type">boolean</span> var1)</span> &#123;<br>      <span class="hljs-built_in">this</span>.enable = var1;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">click</span><span class="hljs-params">()</span> &#123;<br>      ClickListener.DefaultImpls.click(<span class="hljs-built_in">this</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>MyButton</code>类实现<code>ClickListener</code>接口后，重写了<code>getEnable()</code>，这是必须重写的，但是因为我在 Kotlin 的<code>MyButton</code>类中将<code>enable</code>以<code>var</code>来声明，导致编译器在 Java 里又帮我添加了一个<code>setEnable()</code>，同时它还声明了<code>private boolean enable;</code>（<code>enable</code>没有初始化为<code>false</code>是因为 boolean 默认为<code>false</code>），这样一来，一个具备 getter 和 setter 的属性就声明完成了……也就是说，我在 Kotlin 接口中声明的属性，被反编译至 Java 后，先是在 Java 的接口定义处变成了函数，然后在接口实现处又变回了属性。而<code>click()</code>也经历了重写，只不过因为它有默认实现，所以这个重写就是简单的调用这个实现就行了。</p><h3 id="更多例子"><a href="#更多例子" class="headerlink" title="更多例子"></a>更多例子</h3><ul><li>类型推导，定义变量时省略的变量类型，最终会被编译器补充回来。</li><li>字符串模板，编译器最终会将它们转换成 Java 中拼接的形式。</li><li>when 表达式，编译器最终会将它们转换成类似 switch case 的语句。</li><li>类默认 public ，定义类时省略的 public 最终会被编译器补充回来。</li><li>嵌套类默认 static ，嵌套类默认会被添加<code>static</code>关键字，将其变成静态内部类，防止不必要的内存泄漏。</li><li>数据类，定义数据类只用一行代码，编译器在后期补充了很多相关函数。</li></ul><h2 id="object-关键字"><a href="#object-关键字" class="headerlink" title="object 关键字"></a>object 关键字</h2><p>Kotlin 中的<code>object</code>关键字有着三种迥然不同的语义，分别可以定义：</p><ul><li>匿名内部类</li><li>单例模式</li><li>伴生对象</li></ul><p>之所以会出现这样的情况，是因为设计者认为，这三种语义本质上都是在定义一个类的同时还创建了对象。</p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类通常只使用一次（因为它是匿名的），并且会继承一个父类或者实现一个接口。</p><p>在 Java 中不使用匿名内部类是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaLab</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Human</span> <span class="hljs-variable">human</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Human</span>();<br>        human.walk();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">walk</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 手动继承抽象类并实现抽象函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Human</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">walk</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Human walk.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>变量命名的意义可能不大，不过重点在于<code>Human</code>类重写了<code>walk()</code>，并且只用了一次，那大可使用匿名内部类的方式来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaLab</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 写法是添加花括号，括号内部就是匿名类的实现，并且该类会继承 Animal</span><br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">animal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">walk</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-comment">// 匿名内部类继承 Animal 后实现抽象函数</span><br>            &#125;<br>        &#125;;<br>        animal.walk();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">walk</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种写法同样可以用于接口上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaLab</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 可以这么写</span><br>        <span class="hljs-type">Foo</span> <span class="hljs-variable">foo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Bar</span><span class="hljs-params">()</span> &#123;<br>                <br>            &#125;<br>        &#125;;<br>        foo.Bar();<br>        <br>        <span class="hljs-comment">// 也可以简化这么写</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Bar</span><span class="hljs-params">()</span> &#123;<br>                <br>            &#125;<br>        &#125;.Bar();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Foo</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">Bar</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>甚至可以使用 Lambda 语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Foo</span> <span class="hljs-variable">foo</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br><br>    &#125;;<br>    foo.Bar();<br><br>    ((Foo) () -&gt; &#123;<br><br>    &#125;).Bar();<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来看一些一般用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 继承`Thread`类来开启线程</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.run();<br>    &#125;<br>&#125;;<br>thread.start();<br><br><span class="hljs-comment">// 实现`Runnable`接口来开启线程</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>    <span class="hljs-comment">// 编写 run() 中的逻辑</span><br>&#125;;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable);<br>myThread.start();<br><br><span class="hljs-comment">// 在 Android 中为按钮控件添加点击事件</span><br><span class="hljs-type">Button</span> <span class="hljs-variable">button</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>();  <span class="hljs-comment">// 此处报错，需要提供上下文，不过不是重点</span><br>button.setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnClickListener() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View view)</span> &#123;<br>        <span class="hljs-comment">// 按钮点击逻辑</span><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>Kotlin 则通过<code>object</code>关键字来创建匿名内部类，并且同样需要重写那些未实现的函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 在 Android 中为按钮控件添加点击事件</span><br><span class="hljs-keyword">val</span> bt = Button(<span class="hljs-keyword">this</span>)<br>bt.setOnClickListener(<span class="hljs-keyword">object</span> : View.OnClickListener &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onClick</span><span class="hljs-params">(p0: <span class="hljs-type">View</span>?)</span></span> &#123;<br>        TODO(<span class="hljs-string">&quot;Not yet implemented&quot;</span>)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>只不过跟 Java 不一样的是，Kotlin 可以同时继承一个类和实现多个接口：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 实现了 Foo 和 Foo2 两个接口以及一个抽象类 Foo3</span><br>    <span class="hljs-keyword">val</span> temp = <span class="hljs-keyword">object</span> : Foo, Foo2, Foo3() &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span> &#123;<br>            TODO(<span class="hljs-string">&quot;Not yet implemented&quot;</span>)<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar2</span><span class="hljs-params">()</span></span> &#123;<br>            TODO(<span class="hljs-string">&quot;Not yet implemented&quot;</span>)<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar3</span><span class="hljs-params">()</span></span> &#123;<br>            TODO(<span class="hljs-string">&quot;Not yet implemented&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Foo</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Foo2</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar2</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo3</span> &#123;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar3</span><span class="hljs-params">()</span></span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h4 id="object"><a href="#object" class="headerlink" title="object"></a>object</h4><p>Kotlin 中最简单的定义单例类的方式就是通过<code>object</code>关键字：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    Singleton.foo()<br>&#125;<br><br><span class="hljs-comment">// 不需要 class 修饰</span><br><span class="hljs-keyword">object</span> Singleton &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来将 Kotlin 字节码反编译至 Java 看看 Kotlin 是如何使用<code>object</code>关键字实现单例类的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KotlinLabKt</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>      Singleton.INSTANCE.foo();<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] var0)</span> &#123;<br>      main();<br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>   <br>   <span class="hljs-comment">// 创建一个该类的成员变量</span><br>   <span class="hljs-meta">@NotNull</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>   &#125;<br><br>   <span class="hljs-comment">// 私有化构造函数</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>   &#125;<br><br>   <span class="hljs-keyword">static</span> &#123;<br>      <span class="hljs-type">Singleton</span> <span class="hljs-variable">var0</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>      INSTANCE = var0;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，尽管编写过程很简单，但是编译器还是在背后把该做的都做了，包括私有化构造函数、创建一个该类的成员变量，并用<code>static</code>修饰。不过仍然有需要注意的地方：程序中并没有出现我们熟悉的<code>getInstance()</code>之类的用于获取实例的函数，也没有双重检查用于保证线程安全，并且<code>INSTANCE</code>变量，也就是我们用于返回的实例变量，还被<code>final</code>修饰了——这一切其实都是因为<code>static{}</code>代码块。在<code>static{}</code>代码块中的代码，将由虚拟机保证只会被执行一次，也就是保证了线程安全，就不需要双重检查了，同时又保证了<code>INSTANCE</code>变量只会被赋值一次，所以就用<code>final</code>修饰了。同时也可以看到，调用方式为<code>单例类名.实例对象名.函数名</code>。</p><p>这样的单例类真的很简洁明了，看得很舒服，但是也存在两个很明显的不足：</p><ul><li>不支持懒加载（懒汉和饿汉）。</li><li>不支持传参构造单例（例如无法传递上下文）。</li></ul><h4 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span>() &#123;<br>    <span class="hljs-keyword">object</span> DataManager &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadData</span><span class="hljs-params">()</span></span>: Data &#123;<br>            <span class="hljs-comment">// 执行网络请求</span><br>            <span class="hljs-keyword">return</span> Data()<br>        &#125;<br>        <br>        <span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span> <span class="hljs-keyword">by</span> lazy &#123;<br>            loadData()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 by lazy 把属性包裹起来，只要<code>data</code>没有被使用过，就不会触发<code>loadData()</code>。这其实是一种简洁与性能的折中方案。一个对象所占用的内存资源毕竟不大，但是从服务器去请求数据所消耗的资源就会大很多，能保证这个部分是懒加载就算不错了。</p><h4 id="Double-Check"><a href="#Double-Check" class="headerlink" title="Double Check"></a>Double Check</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span>() &#123;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-comment">// 使用 @Volatile 注解保证同步性</span><br>        <span class="hljs-meta">@Volatile</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> instance: Singleton? = <span class="hljs-literal">null</span><br>        <span class="hljs-comment">// 第一次使用 elvis 操作符进行判空</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>: Singleton = instance ?: synchronized(<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-comment">// 第二次判空</span><br>            instance ?: Singleton().also &#123; instance = it &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个写法其实也来自 Google ：<a href="https://github.com/android/architecture-components-samples/blob/master/BasicRxJavaSampleKotlin/app/src/main/java/com/example/android/observability/persistence/UsersDatabase.kt">architecture-components-samples&#x2F;UsersDatabase.kt at master · android&#x2F;architecture-components-samples · GitHub</a>，本质上和 Java 的双重检查没什么区别。</p><h4 id="抽象类模板"><a href="#抽象类模板" class="headerlink" title="抽象类模板"></a>抽象类模板</h4><p>Double Check 是很好的方案，既解决了懒加载又满足了传参，可是它还不够完美，因为针对不同的类，每次都要把逻辑从头写一遍，每次都要写一遍 Double Check 就很麻烦，那么如何复用这部分操作呢。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 使用</span><br>    <span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span> = Data.getInstance(<span class="hljs-string">&quot;&quot;</span>)<br>    <span class="hljs-keyword">data</span>.foo()<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseSingleton</span>&lt;<span class="hljs-type">in P, out T</span>&gt; &#123;<br>    <span class="hljs-meta">@Volatile</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> instance: T? = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">create</span><span class="hljs-params">(param: <span class="hljs-type">P</span>)</span></span>: T<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getInstance</span><span class="hljs-params">(param: <span class="hljs-type">P</span>)</span></span>: T = instance ?: synchronized(<span class="hljs-keyword">this</span>) &#123;<br>        instance ?: create(param).also &#123; instance = it &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span>() &#123;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> : BaseSingleton&lt;String, Data&gt;() &#123;<br>        <span class="hljs-comment">// 实例化对象的逻辑将放在 create() 中</span><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">create</span><span class="hljs-params">(param: <span class="hljs-type">String</span>)</span></span>: Data &#123;<br>            <span class="hljs-comment">// 可以进行一些额外处理</span><br>            <span class="hljs-keyword">return</span> Data()<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>利用泛型并通过继承一个抽象类并实现其抽象函数，可以把重复的工作放在抽象类当中，然后把如何实例化的逻辑抽取出来，针对不同的类编写不一样的逻辑。例如上面的例子中，<code>Data</code>类中的伴生对象（伴生对象也是一个类）在继承<code>BaseSingleton&lt;in P, out T&gt;</code>以后就只需要重写<code>create()</code>，保证其最终返回一个<code>Data</code>对象就行了。至于 Volatile 和双重检查的逻辑，已经在抽象类中实现了。</p><h3 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h3><p>Kotlin 中没有<code>static</code>关键字，想要定义静态变量和静态函数，需要使用到伴生对象也就是<code>companion object</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    Foo.name = <span class="hljs-string">&quot;Aiden&quot;</span><br>    Foo.bar()<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span> &#123;<br>            println(<span class="hljs-string">&quot;my name is <span class="hljs-variable">$name</span>&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就很有静态的感觉。那么<code>object{}</code>和<code>companion object{}</code>都可以在类的内部声明，那它们之间有什么区别呢。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    ObjectTest.InnerSingleton.foo()<br>    ObjectTest.InnerSingleton.name = <span class="hljs-string">&quot;Aiden&quot;</span><br>    println(ObjectTest.InnerSingleton.name)<br><br>    CompanionObjectTest.bar()<br>    println(CompanionObjectTest.name)<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectTest</span> &#123;<br>    <span class="hljs-keyword">object</span> InnerSingleton &#123;<br>        <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;&#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CompanionObjectTest</span> &#123;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> name = <span class="hljs-string">&quot;Aiden&quot;</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span> &#123;&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>反编译至 Java ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KotlinLabKt</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>      ObjectTest.InnerSingleton.INSTANCE.foo();<br>      CompanionObjectTest.Companion.bar();<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] var0)</span> &#123;<br>      main();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，<code>object{}</code>由于被嵌入到一个类中，所以在调用的时候会比<code>companion object{}</code>多一层，如果想要去掉这一层（.INSTANCE），可以在<code>fun foo() {}</code>上边加上<code>@JvmStatic</code>注解，再次反编译就会发现少了这一层，不过感觉也没什么卵用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectTest</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerSingleton</span> &#123;<br>      <span class="hljs-meta">@NotNull</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Aiden&quot;</span>;<br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> age;<br>      <span class="hljs-meta">@NotNull</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> InnerSingleton INSTANCE;<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>         <span class="hljs-keyword">return</span> age;<br>      &#125;<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> var1)</span> &#123;<br>         age = var1;<br>      &#125;<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>      &#125;<br><br>      <span class="hljs-keyword">private</span> <span class="hljs-title function_">InnerSingleton</span><span class="hljs-params">()</span> &#123;<br>      &#125;<br><br>      <span class="hljs-keyword">static</span> &#123;<br>         <span class="hljs-type">InnerSingleton</span> <span class="hljs-variable">var0</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InnerSingleton</span>();<br>         INSTANCE = var0;<br>         age = <span class="hljs-number">23</span>;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，<code>object{}</code>就是把单例类嵌入到类中（在<code>static{}</code>代码块中执行一些变量初始化操作），然后通过实例对象来调用变量和 getter 和 setter 以及其它函数。只不过相比直接使用<code>object</code>定义单例类，嵌入到类中的单例类还会被<code>static</code>修饰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CompanionObjectTest</span> &#123;<br>   <span class="hljs-meta">@NotNull</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Aiden&quot;</span>;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">23</span>;<br>   <span class="hljs-meta">@NotNull</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Companion</span> <span class="hljs-variable">Companion</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Companion</span>((DefaultConstructorMarker)<span class="hljs-literal">null</span>);<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Companion</span> &#123;<br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>         <span class="hljs-keyword">return</span> CompanionObjectTest.age;<br>      &#125;<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> var1)</span> &#123;<br>         CompanionObjectTest.age = var1;<br>      &#125;<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bar</span><span class="hljs-params">()</span> &#123;<br>      &#125;<br><br>      <span class="hljs-keyword">private</span> <span class="hljs-title function_">Companion</span><span class="hljs-params">()</span> &#123;<br>      &#125;<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-title function_">Companion</span><span class="hljs-params">(DefaultConstructorMarker $constructor_marker)</span> &#123;<br>         <span class="hljs-built_in">this</span>();<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而<code>companion object{}</code>就有点不一样了，它首先把所有的变量放在类的最外层并且用<code>static</code>修饰，然后新建了一个叫<code>Companion</code>的静态内部类，其中包含了所有的函数（包括最外层的那些变量的 getter 和 setter）。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>看了<code>object{}</code>和<code>companion object{}</code>反编译代码的对比，感觉也没什么特别的，不如来总结一下单例类的用法：</p><ul><li>如果单例占用内存很小，并且对内存不敏感，不需要传参，直接使用<code>object</code>定义即可。</li><li>如果单例占用内存很小，不需要传参，但它内部的属性会触发消耗资源的网络请求和数据库查询，则可以使用<code>object</code>搭配懒加载。</li><li>如果工程很简单，只有一两个单例场景，同时有懒加载需求，并且需要传参，则可以直接手写 Double Check 。</li><li>如果工程规模大，对内存敏感，单例场景比较多，那就很有必要使用抽象类模板了。</li></ul><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h3><p>扩展函数是个函数，函数可以被类实例对象调用，所以扩展很明显指的就是扩展这个类了。但是函数明明可以直接写在类里，想要什么功能就写什么函数，为什么还要扩展？所以很明显，扩展的往往是那些不能被修改的类。来看个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;1000秒是多少分多少秒呢？是<span class="hljs-subst">$&#123;<span class="hljs-number">1000.</span>toMinSec()&#125;</span>&quot;</span>)<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">toMinSec</span><span class="hljs-params">()</span></span>: String &#123;<br>    <span class="hljs-keyword">val</span> min = <span class="hljs-keyword">this</span> / <span class="hljs-number">60</span>  <span class="hljs-comment">// this 代表调用这个函数的 Int 对象</span><br>    <span class="hljs-keyword">val</span> sec = <span class="hljs-keyword">this</span> % <span class="hljs-number">60</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;<span class="hljs-variable">$min</span>:<span class="hljs-variable">$sec</span>&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>toMinSec()</code>的具体逻辑是什么并不重要。重点在于<code>Int</code>类是 Kotlin 官方的类，是不能被修改的，但是<code>toMinSec()</code>作为扩展函数，它扩展了<code>Int</code>类，这样一来，<code>Int</code>类对象就可以直接调用这个函数。扩展函数的好处就在于方便且符合直觉：这个功能就是和这个类相关的，那么这个类的对象就应该可以直接调用函数。</p><p>编写扩展函数的关键在于函数的声明处，在上面的例子中，<code>Int.toMinSec()</code>代表的是将名为<code>toMinSec()</code>的函数作为<code>Int</code>类的扩展函数，在后续的使用中，如上面的<code>1000</code>，作为<code>Int</code>对象，就可以直接调用这个函数。还有一点就是函数当中的<code>this</code>关键字，这个关键字在函数内代表的是调用这个函数的对象，在上面的例子中就是<code>1000</code>。</p><p>接下来利用反编译看一下扩展函数神奇在哪里（为了简化，这里就把函数内的逻辑改成一行打印）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    toMinSec(<span class="hljs-number">100</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">toMinSec</span><span class="hljs-params">(<span class="hljs-type">int</span> $<span class="hljs-built_in">this</span>$toMinSec)</span> &#123;<br>    System.out.println($<span class="hljs-built_in">this</span>$toMinSec);<br>&#125;<br></code></pre></td></tr></table></figure><p>不难看出，Kotlin 编写的扩展函数，最终会变成静态函数的调用，并没有修改任何类的源码。</p><h3 id="扩展属性"><a href="#扩展属性" class="headerlink" title="扩展属性"></a>扩展属性</h3><p>扩展属性也是类似：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;Aiden&quot;</span>.foo)<br>&#125;<br><br><span class="hljs-keyword">val</span> String.foo<br>    <span class="hljs-keyword">get</span>() = <span class="hljs-string">&quot;bar&quot;</span><br></code></pre></td></tr></table></figure><p>可以看到，区别只是将<code>fun</code>改成<code>val</code>&#x2F;<code>var</code>而已，然后把函数体改成 get 函数，函数内同样可以通过<code>this</code>关键字引用这个 String 对象。针对这个例子反编译至 Java 会发现扩展属性的实现同样是一个静态函数，函数名为<code>getFoo</code>。</p><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><p>扩展并非无所不能，因为其本质终究是一个静态函数，这就导致了至少 3 个限制：</p><ul><li>无法被重写。这很好理解，假设为 A 类编写了一个扩展函数（这个扩展函数位于顶层），这个 A 类是用<code>open</code>修饰的，然后 B 类继承了 A 类，但是就算这样还是无法重写这个扩展函数，因为这个扩展函数根本就不是 A 类的成员。如果非要重写，那可以把这个扩展函数写在 A 类的里面，但是这样又没意义了，如果可以修改类的代码，那还要扩展函数做什么。</li><li>扩展属性无法存储状态。对于扩展属性，可以编写 get 函数，但是编写 set 函数的时候并不能调用<code>field</code>进行赋值。</li><li>访问的作用域仅限于两处。一是扩展声明所在的作用域的变量（例如在顶层），扩展可以访问，哪怕这个变量是私有的。二是被扩展类的公开成员，例如扩展了 String 类，那么就可以调用 String 类的<code>length</code>属性，至于 String 类的私有成员，扩展则无法访问。</li></ul><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>高阶函数就是将函数用作参数或返回值的函数。在 Android 开发中，为控件添加点击监听是一个很好的例子，如果用 Java 为一个按钮添加点击监听，一般这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Button</span> <span class="hljs-variable">button</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>();  <span class="hljs-comment">// 报错，缺少上下文，不重要</span><br>button.setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnClickListener() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View view)</span> &#123;<br>        <span class="hljs-comment">// 点击事件</span><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>同样的功能，用 Kotlin 来写，写法会简单很多，同时可读性也增加了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Button(<span class="hljs-keyword">this</span>).setOnClickListener &#123;<br>    <span class="hljs-comment">// 点击事件</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>函数类型是高阶函数中一个比较重要的概念，变量有类型，函数也能有类型吗？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">(bar: <span class="hljs-type">Int</span>)</span></span>: String = <span class="hljs-string">&quot;6&quot;</span><br></code></pre></td></tr></table></figure><p>以上边的<code>foo()</code>为例，它的函数类型就是<code>(Int) -&gt; String</code>，意思是这个函数接收一个整型的参数然后返回一个字符串类型的值。其它的类型比方说还有<code>() -&gt; Unit</code>、<code>Int.() -&gt; Unit</code>等等。可以看到，函数类型由以下信息组成：</p><ul><li>函数接收的参数的数量和类型。</li><li>函数是否是扩展函数（或者说是否带有接收者）。</li><li>函数的返回值类型。</li></ul><p>此外还可以通过函数引用的函数来确认函数类型，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> method: (<span class="hljs-built_in">Int</span>) -&gt; String = ::foo  <span class="hljs-comment">// 双冒号表示函数引用</span><br></code></pre></td></tr></table></figure><p>编译器没有报错，说明我们通过了编译器的检查，肯定了<code>foo()</code>的类型就是<code>(Int) -&gt; String</code>。</p><h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3><p>Lambda 可以理解为函数的简写，在上方的<code>setOnClickListener</code>的写法之前，其实还存在 8 种过渡写法，可以了解一下：</p><h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><p>最原始的状态，本质是用<code>object</code>关键字定义了一个匿名内部类去实现<code>OnClickListener</code>这个接口：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">button.setOnClickListener(<span class="hljs-keyword">object</span> : View.OnClickListener &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onClick</span><span class="hljs-params">(p0: <span class="hljs-type">View</span>?)</span></span> &#123;<br>        <span class="hljs-comment">// 点击逻辑</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h4><p><code>object</code>关键字可以省略，重写的函数也可以省略函数体，直接把逻辑写在花括号里：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">button.setOnClickListener(View.OnClickListener &#123; view: View? -&gt;<br>    <span class="hljs-comment">// 点击逻辑</span><br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h4><p><code>View.OnClickListener</code>可以省略不写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">button.setOnClickListener(&#123; view: View? -&gt;<br>    <span class="hljs-comment">// 点击逻辑</span><br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h4><p>编译器可以推导类型，所以<code>View?</code>可以省略不写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">button.setOnClickListener(&#123; view -&gt;<br>    <span class="hljs-comment">// 点击逻辑</span><br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h4><p>当表达式中只存在一个参数的时候，这个参数可以用<code>it</code>来代表：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">button.setOnClickListener(&#123; it -&gt;<br>    <span class="hljs-comment">// 点击逻辑</span><br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="第六步"><a href="#第六步" class="headerlink" title="第六步"></a>第六步</h4><p><code>it</code>可以省略不写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">button.setOnClickListener(&#123;<br>    <span class="hljs-comment">// 点击逻辑</span><br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="第七步"><a href="#第七步" class="headerlink" title="第七步"></a>第七步</h4><p>当 Lambda 作为函数的最后一个参数时，花括号可以被挪到括号外面：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">button.setOnClickListener() &#123;<br>    <span class="hljs-comment">// 点击逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="第八步"><a href="#第八步" class="headerlink" title="第八步"></a>第八步</h4><p>当只有一个 Lambda 作为函数参数时，括号都可以省略不写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">button.setOnClickListener &#123;<br>    <span class="hljs-comment">// 点击逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SAM"><a href="#SAM" class="headerlink" title="SAM"></a>SAM</h3><p>要想使用 Lambda 表达式，一般需要满足 SAM 。SAM 是 Single Abstract Method 的缩写，意思就是只有一个抽象函数的类或者接口。只要是符合 SAM 要求的接口，编译器就能进行 SAM 转换，在编写过程中就可以直接使用 Lambda 表达式。</p><p>但是从 Java 8 开始，SAM 就有了明确的名称，叫做函数式接口（Functional interface），并且想要实现函数式接口，就要满足两个条件，缺一不可：</p><ul><li>只能是接口，抽象类不行了。</li><li>接口只有一个抽象函数（接口中的函数默认是抽象的），默认实现的函数可以有多个。</li></ul><p>并且从 Kotlin 1.4 开始，想要在 Kotlin 中实现函数式接口，必须要用<code>fun interface</code>来声明，普通的接口已经不行了，抽象类也不行。</p><p>了解规则后，接下来用代码解释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaLab</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Test</span><span class="hljs-params">(IFoo foo)</span> &#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IFoo</span> &#123;<br>    <span class="hljs-comment">// 单抽象函数</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">bar</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">// 多个默认实现</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bar2</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>    <span class="hljs-comment">// 多个默认实现</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bar3</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    test &#123;<br><br>    &#125;<br><br>    test2(<span class="hljs-keyword">object</span> : Foo2 &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar2</span><span class="hljs-params">()</span></span> &#123;<br>            TODO(<span class="hljs-string">&quot;Not yet implemented&quot;</span>)<br>        &#125;<br>    &#125;)<br><br>    JavaLab.Test &#123;<br><br>    &#125;<br><br>    test3(<span class="hljs-string">&quot;Aiden&quot;</span>) &#123;<br>        print(<span class="hljs-string">&quot;My name is &quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 函数式接口（Functional interface）</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-keyword">interface</span> Foo &#123;</span><br>    <span class="hljs-comment">// 单抽象函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span><br><br>    <span class="hljs-comment">// 默认实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">rab</span><span class="hljs-params">()</span></span> &#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 普通函数，接收一个实现了 Foo 接口的对象</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(foo: <span class="hljs-type">Foo</span>)</span></span> &#123;<br><br>&#125;<br><br><span class="hljs-comment">// 普通接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Foo2</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar2</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-comment">// 普通函数，接收一个实现了 Foo2 接口的对象</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test2</span><span class="hljs-params">(foo2: <span class="hljs-type">Foo2</span>)</span></span> &#123;<br><br>&#125;<br><br><span class="hljs-comment">// 高阶函数，接收了一个函数类型的参数</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test3</span><span class="hljs-params">(name: <span class="hljs-type">String</span>, hello: () -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>    hello.invoke()<br>    print(name)<br>&#125;<br></code></pre></td></tr></table></figure><p>一个一个说明：</p><ul><li>Java 中的静态函数<code>Test()</code>在 Kotlin 中被直接引用，函数接收一个实现了<code>IFoo</code>接口的对象。<code>IFoo</code>接口尽管有多个默认实现函数（被<code>default</code>修饰），但只有一个抽象函数，并且因为<code>IFoo</code>是接口，所以是满足 SAM 的，所以在 Kotlin 中调用<code>Test()</code>时可以直接使用 Lambda 表达式。</li><li>Kotlin 中的<code>Foo</code>接口被<code>fun interface</code>修饰，所以<code>Foo</code>接口已经被定性为函数式接口，在该接口中可以有多个默认实现的函数，但是如果没有抽象函数或者有多个抽象函数，编译器将会报错。因为<code>test()</code>接收一个实现了<code>Foo</code>接口的对象，所以在调用<code>test()</code>时可以直接使用 Lambda 表达式。</li><li><code>Foo2</code>接口是普通的接口，并不满足 SAM ，所以<code>test2()</code>就算接收了它也不能使用 Lambda 表达式。</li><li>抽象类也不满足 SAM ，也不能使用 Lambda 表达式，在代码里就不演示了。</li><li>使用 Lambda 表达式不一定要满足 SAM ，<code>test3()</code>是高阶函数，并且把函数类型的参数放在了参数列表最后面，所以在调用<code>test3()</code>的时候也可以使用 Lambda 表达式。</li></ul><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>函数式编程（Functional Programming），是一个跟「面向对象」类似的概念，它也是软件工程中的一种编程范式，它是声明式编程（Declarative Programming）的一种，而与它相反的叫做命令式编程（Imperative Programming）。这些概念之间的关系大概是这样：</p><p><img src="/images/Notes/Programming-Paradigm.png" alt="编程范式"></p><p>像 C 和 Java ，它们分别属于面向过程、面向对象的语言，同时又都属于命令式的范畴。使用命令式语言进行编程，一般就是根据思路，告诉计算机每一步该做什么，比如现在要从一个集合中找出所有的偶数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findEvenNumber</span><span class="hljs-params">(list: <span class="hljs-type">List</span>&lt;<span class="hljs-type">Int</span>&gt; = listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span></span>): List&lt;<span class="hljs-built_in">Int</span>&gt; &#123;<br>    <span class="hljs-keyword">val</span> evenList = mutableListOf&lt;<span class="hljs-built_in">Int</span>&gt;()  <span class="hljs-comment">// 新建一个集合用来存放结果</span><br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> list) &#123;  <span class="hljs-comment">// 遍历数组</span><br>        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)  <span class="hljs-comment">// 判断是否能被 2 整除</span><br>            evenList.add(i)  <span class="hljs-comment">// 如果能就把这个数加入到结果中</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> evenList  <span class="hljs-comment">// 返回这个集合</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但是如果是声明式代码就需要这么写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// `filter()`是 Kotlin 集合类中的一个高阶函数，作用是将集合中符合 Lambda 表达式中要求的元素返回</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findEvenNumber</span><span class="hljs-params">(list: <span class="hljs-type">List</span>&lt;<span class="hljs-type">Int</span>&gt; = listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span></span>) = list.filter &#123; it % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#125;<br></code></pre></td></tr></table></figure><p>通过对比还是会感觉到风格上有不一样，那么到底如何理解 Kotlin 中的函数式编程，简单来说，有这么两点：</p><ul><li>函数在 Kotlin 中至关重要。<ul><li>函数可以独立于类之外，成为顶层函数；</li><li>函数可以作为参数和返回值，也就是高阶函数和 Lambda ；</li><li>函数可以像变量一样被引用；</li></ul></li><li>纯函数。<ul><li>函数不应该有副作用（不应该对函数作用域以外的数据进行修改）。</li><li>具有幂等性（调用一次和调用 N 次，效果是等价的）。</li><li>具有引用透明的特性。</li><li>它具有无状态的特性。</li></ul></li></ul><h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><p>Kotlin 的委托和扩展差不多，都有两个应用场景，一个是委托类，另一个是委托属性，<strong>前者委托的是接口函数，后者委托的是属性的 getter 和 settter</strong> 。</p><h3 id="委托类"><a href="#委托类" class="headerlink" title="委托类"></a>委托类</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    UniversalAction(Dog()).move()<br>    UniversalAction(Person()).move()<br>&#125;<br><br><span class="hljs-comment">// 定义一个关于动作的接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Action</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">move</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-comment">// 定义了一个狗类并实现了 Action 接口重写了 move()</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> : <span class="hljs-type">Action</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">move</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;狗是爬的&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义了一个人类并实现了 Action 接口重写了 move()</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> : <span class="hljs-type">Action</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">move</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;人是走的&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 通过 by 关键字进行委托</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UniversalAction</span>(action: Action) : Action <span class="hljs-keyword">by</span> action<br></code></pre></td></tr></table></figure><p>输出结果是：</p><blockquote><p>狗是爬的<br>人是走的</p></blockquote><p>重点在于<code>UniversalAction</code>这个类，该类也实现了<code>Action</code>接口，只不过并没有重写<code>move()</code>，而是通过<code>by</code>关键字把<code>move()</code>的实现委托给了构造函数的参数，到时候直接用参数的<code>move()</code>就行了。这样一来<code>UniversalAction</code>就相当于一个壳，它并不关心<code>move()</code>具体怎么实现，只要传入不同的参数，就会有不同的行为</p><h3 id="委托属性"><a href="#委托属性" class="headerlink" title="委托属性"></a>委托属性</h3><h4 id="直接委托"><a href="#直接委托" class="headerlink" title="直接委托"></a>直接委托</h4><p>从 Kotlin 1.4 开始可以直接在语法层面将一个属性委托给另一个属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    Foo().run &#123;<br>        println(<span class="hljs-string">&quot;count = <span class="hljs-variable">$count</span> | total = <span class="hljs-variable">$total</span>&quot;</span>)<br>        count = <span class="hljs-number">1</span><br>        println(<span class="hljs-string">&quot;count = <span class="hljs-variable">$count</span> | total = <span class="hljs-variable">$total</span>&quot;</span>)<br>        total = <span class="hljs-number">2</span><br>        println(<span class="hljs-string">&quot;count = <span class="hljs-variable">$count</span> | total = <span class="hljs-variable">$total</span>&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<br>    <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">var</span> total <span class="hljs-keyword">by</span> ::count<br>&#125;<br></code></pre></td></tr></table></figure><p>这种情况下<code>count</code>和<code>total</code>是完全一致的，因为<code>total</code>的 getter 和 setter 都委托给了<code>count</code>。其中<code>count</code>前面的两个冒号代表属性的引用。</p><h4 id="懒加载委托"><a href="#懒加载委托" class="headerlink" title="懒加载委托"></a>懒加载委托</h4><p>懒加载的应用非常广泛，对于一些需要消耗较多资源的操作，如果希望它只有在被访问的时候才去执行（从而避免不必要的资源开销），就可以使用懒加载。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(result)<br>    println(result)<br>&#125;<br><br><span class="hljs-keyword">val</span> result: String <span class="hljs-keyword">by</span> lazy &#123;<br>    request()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">request</span><span class="hljs-params">()</span></span>: String &#123;<br>    println(<span class="hljs-string">&quot;这里执行一些耗时的请求操作&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;请求结果&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面模拟了一个网络请求，<code>result</code>通过<code>by lazy</code>进行委托，也就是只有在调用到<code>result</code>的时候才会去执行 Lambda 中的代码。主函数中第一次调用<code>result</code>触发了懒加载，执行了<code>request()</code>，返回了一个字符串，而当第二次调用<code>result</code>的时候，因为已经知道了<code>result</code>的值，所以就直接返回了字符串，而没有再去执行<code>request()</code>中的内容。</p><p>另外，<code>lazy()</code>是一个高阶函数，函数接收两个参数，一个是<code>LazyThreadSafetyMode</code>枚举，一个是函数类型的参数。如果不传这个枚举参数的话，实际上调用的是单参数版本的<code>lazy()</code>，而单参数的<code>lazy()</code>默认就是调用<code>SynchronizedLazyImpl()</code>这个线程同步的实现。</p><h4 id="观察者委托"><a href="#观察者委托" class="headerlink" title="观察者委托"></a>观察者委托</h4><p><a href="https://kotlinlang.org/docs/delegated-properties.html">&#x2F;&#x2F; TODO</a></p><h4 id="映射委托"><a href="#映射委托" class="headerlink" title="映射委托"></a>映射委托</h4><p><a href="https://kotlinlang.org/docs/delegated-properties.html">&#x2F;&#x2F; TODO</a></p><h3 id="自定义委托"><a href="#自定义委托" class="headerlink" title="自定义委托"></a>自定义委托</h3><p>自定义委托需要遵循一个格式，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomDelegate</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> string: String) &#123;<br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Owner</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> string<br>    &#125;<br><br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Owner</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;, value: <span class="hljs-type">String</span>)</span></span> &#123;<br>        string = value<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Owner</span> &#123;<br>    <span class="hljs-keyword">var</span> text: String <span class="hljs-keyword">by</span> CustomDelegate(<span class="hljs-string">&quot;Foobar&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>有 3 点需要注意：</p><ul><li>对于<code>var</code>修饰的属性来说，需要有<code>getValue()</code>和<code>setValue()</code>，同时这两个函数需要被<code>operator</code>关键字修饰。</li><li>变量<code>text</code>位于<code>Owner</code>类中，所以<code>getValue()</code>和<code>setValue()</code>中的第一个参数需要是<code>Owner</code>类或者是它的父类。</li><li>变量<code>text</code>是 String 类型，所以<code>getValue()</code>的返回值类型和<code>setValue()</code>的第三个参数都应该要是 String 类型或者是它的父类。</li></ul><p>如果觉得手动编写过于繁琐，还可以通过实现 Kotlin 官方提供的接口的形式来快速自定义委托，对于<code>val</code>声明的属性，就需要继承<code>ReadOnlyProperty</code>接口：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Base interface that can be used for implementing property delegates of read-only properties.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This is provided only for convenience; you don&#x27;t have to extend this interface</span><br><span class="hljs-comment"> * as long as your property delegate has methods with the same signatures.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> T the type of object which owns the delegated property.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> V the type of the property value.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-keyword">interface</span> ReadOnlyProperty<span class="hljs-type">&lt;in T, out V&gt;</span> &#123;</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns the value of the property for the given object.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> thisRef the object for which the value is requested.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> property the metadata for the property.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the property value.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">T</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: V<br>&#125;<br></code></pre></td></tr></table></figure><p>注意一下，<code>ReadOnlyProperty()</code>使用<code>fun interface</code>进行声明，说明在 Kotlin 中，它就是一个符合 SAM 规则的函数式接口，事实上它也的确只有一个函数。</p><p>言归正传，对于<code>var</code>声明的属性来说，就需要继承<code>ReadWriteProperty</code>接口：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Base interface that can be used for implementing property delegates of read-write properties.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This is provided only for convenience; you don&#x27;t have to extend this interface</span><br><span class="hljs-comment"> * as long as your property delegate has methods with the same signatures.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> T the type of object which owns the delegated property.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> V the type of the property value.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ReadWriteProperty</span>&lt;<span class="hljs-type">in T, V</span>&gt; : <span class="hljs-type">ReadOnlyProperty</span>&lt;<span class="hljs-type">T, V</span>&gt; &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns the value of the property for the given object.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> thisRef the object for which the value is requested.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> property the metadata for the property.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the property value.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">T</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: V<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Sets the value of the property for the given object.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> thisRef the object for which the value is requested.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> property the metadata for the property.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value the value to set.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">T</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;, value: <span class="hljs-type">V</span>)</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    Owner().run &#123;<br>        println(text)<br>        text = <span class="hljs-string">&quot;666&quot;</span><br>        println(text)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Owner</span> &#123;<br>    <span class="hljs-keyword">var</span> text: String <span class="hljs-keyword">by</span> CustomDelegate(<span class="hljs-string">&quot;Foobar&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomDelegate</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> string: String) : ReadWriteProperty&lt;Owner, String&gt; &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Owner</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> string<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Owner</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;, value: <span class="hljs-type">String</span>)</span></span> &#123;<br>        string = value<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果是：</p><blockquote><p>Foobar<br>666</p></blockquote><p>另外，如果想在属性委托之前再做一些额外的判断工作，还可以使用 provideDelegate 来实现。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    Owner().run &#123;<br>        println(textA)<br>        println(textB)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Owner</span> &#123;<br>    <span class="hljs-keyword">var</span> textA <span class="hljs-keyword">by</span> SmartDelegator()<br>    <span class="hljs-keyword">var</span> textB <span class="hljs-keyword">by</span> SmartDelegator()<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomDelegate</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> string: String) : ReadWriteProperty&lt;Owner, String&gt; &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Owner</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> string<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Owner</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;, value: <span class="hljs-type">String</span>)</span></span> &#123;<br>        string = value<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SmartDelegator</span> &#123;<br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideDelegate</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        thisRef: <span class="hljs-type">Owner</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        property: <span class="hljs-type">KProperty</span>&lt;*&gt;</span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>: ReadWriteProperty&lt;Owner, String&gt; &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (property.name.contains(<span class="hljs-string">&quot;A&quot;</span>)) CustomDelegate(<span class="hljs-string">&quot;part A&quot;</span>)<br>        <span class="hljs-keyword">else</span> CustomDelegate(<span class="hljs-string">&quot;part B&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>例如上面这个例子，把<code>Owner</code>的两个属性委托给了<code>SmartDelegator</code>类，而这个类中有一个<code>provideDelegate()</code>，该函数被<code>operator</code>关键字修饰，然后可以对委托进来的属性进行一些判断，最后返回不一样的实现了<code>ReadWriteProperty</code>接口的对象。</p><h3 id="案例-属性封装"><a href="#案例-属性封装" class="headerlink" title="案例 - 属性封装"></a>案例 - 属性封装</h3><p>在类中，对于那些希望只被访问但是不能被修改的属性，可以用<code>val</code>来修饰。但这也仅限于一般数据类型，对于集合来说，只要拿到了实例，就可以调用修改集合的函数。针对这种情况，可以使用委托将一个不可变集合委托给一个可变集合：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    Foo().run &#123;<br>        println(bar.size)  <span class="hljs-comment">// 正常访问</span><br>        <span class="hljs-comment">//bar.add()  // 无法使用，因为是不可变的集合</span><br>        <span class="hljs-comment">//bar = listOf()  // 属性被 val 修饰，不可修改</span><br>        addInt(<span class="hljs-number">1</span>)<br>        addInt(<span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> bar) println(i)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<br>    <span class="hljs-keyword">val</span> bar: List&lt;<span class="hljs-built_in">Int</span>&gt; <span class="hljs-keyword">by</span> ::_bar  <span class="hljs-comment">// 不可变集合，用于给外界访问</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _bar = mutableListOf&lt;<span class="hljs-built_in">Int</span>&gt;()  <span class="hljs-comment">// 可变集合</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">addInt</span><span class="hljs-params">(element: <span class="hljs-type">Int</span>)</span></span> &#123;<br>        _bar.add(element)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样一来，当需要访问集合时就调用<code>bar</code>，但是却不能直接调用集合的<code>add()</code>等函数。</p><h3 id="案例-数据绑定"><a href="#案例-数据绑定" class="headerlink" title="案例 - 数据绑定"></a>案例 - 数据绑定</h3><p>如果需要将控件上的某个属性与代码中的某个变量进行绑定，可以使用 DataBinding ，但是除了 DataBinding 以外，也可以使用自定义委托来实现，这种方式不一定完美，但也算是个有趣的思路。</p><p>这里以修改 TextView 上的文本为例，这是 XML 部分：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/textView&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Foobar&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>然后在 MainActivity 中定义一个顶层函数，同时也是 TextView 的扩展函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> TextView.<span class="hljs-title">provideDelegate</span><span class="hljs-params">(value: <span class="hljs-type">Any</span>?, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span> =<br>    <span class="hljs-keyword">object</span> : ReadWriteProperty&lt;Any?, String?&gt; &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Any</span>?, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: String = text.toString()<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Any</span>?, property: <span class="hljs-type">KProperty</span>&lt;*&gt;, value: <span class="hljs-type">String</span>?)</span></span> &#123;<br>            text = value<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>接着是使用部分：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> tv = findViewById&lt;TextView&gt;(R.id.textView)<br><span class="hljs-keyword">var</span> text: String? <span class="hljs-keyword">by</span> tv<br><br>Log.d(<span class="hljs-string">&quot;@@@&quot;</span>, text.toString())<br>text = <span class="hljs-string">&quot;666&quot;</span><br>Log.d(<span class="hljs-string">&quot;@@@&quot;</span>, tv.text.toString())<br></code></pre></td></tr></table></figure><p>将变量<code>text</code>的 getter 和 setter 托管给了 TextView ，在<code>TextView.provideDelegate()</code>中将其与 TextView 的<code>text</code>属性相关联。最终程序运行会先打印 TextView 在 XML 中定义的文本，修改了<code>text</code>变量后，再打印就会得到修改后的结果。</p><h3 id="案例-ViewModel-委托"><a href="#案例-ViewModel-委托" class="headerlink" title="案例 - ViewModel 委托"></a>案例 - ViewModel 委托</h3><p>ViewModel 在 Android 中经常用来存储界面数据，但是 ViewModel 的实例并不会被直接创建，而是使用委托的方式来获得。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 假设自定义的 ViewModel 类叫 MainViewModel</span><br><span class="hljs-keyword">val</span> viewModel: MainViewModel <span class="hljs-keyword">by</span> viewModels()<br></code></pre></td></tr></table></figure><p>稍微看一下<code>viewModels()</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> VM : ViewModel&gt;</span> ComponentActivity.<span class="hljs-title">viewModels</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">noinline</span> extrasProducer: (() -&gt; <span class="hljs-type">CreationExtras</span>)? = <span class="hljs-literal">null</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">noinline</span> factoryProducer: (() -&gt; <span class="hljs-type">Factory</span>)? = <span class="hljs-literal">null</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>: Lazy&lt;VM&gt; &#123;<br>    <span class="hljs-keyword">val</span> factoryPromise = factoryProducer ?: &#123;<br>        defaultViewModelProviderFactory<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ViewModelLazy(<br>        VM::<span class="hljs-keyword">class</span>,<br>        &#123; viewModelStore &#125;,<br>        factoryPromise,<br>        &#123; extrasProducer?.invoke() ?: <span class="hljs-keyword">this</span>.defaultViewModelCreationExtras &#125;<br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>点进<code>Lazy</code>接口中：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Represents a value with lazy initialization.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * To create an instance of [Lazy] use the [lazy] function.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Lazy</span>&lt;<span class="hljs-type">out T</span>&gt; &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Gets the lazily initialized value of the current Lazy instance.</span><br><span class="hljs-comment">     * Once the value was initialized it must not change during the rest of lifetime of this Lazy instance.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> value: T<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns `true` if a value for this Lazy instance has been already initialized, and `false` otherwise.</span><br><span class="hljs-comment">     * Once this function has returned `true` it stays `true` for the rest of lifetime of this Lazy instance.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isInitialized</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到：</p><ul><li><code>viewModels()</code>是<code>ComponentActivity</code>的扩展函数，所以可以直接在 Activity 中调用<code>viewModels()</code>。</li><li><code>viewModels()</code>返回<code>Lazy</code>接口，而<code>ViewModelLazy</code>是<code>Lazy</code>接口的一个实现类。</li><li><code>Lazy</code>接口中的<code>value</code>属性是用<code>val</code>修饰的，但是接口内并没有定义<code>getValue()</code>，之所以能实现委托，是因为它把<code>getValue()</code>作为扩展函数来定义了。</li></ul><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>在编程时会经常强调“代码复用”，而泛型的存在也算是提供了一种复用的方案。</p><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>假设要编写遥控器类，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 小米电视</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MiTVController</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">on</span><span class="hljs-params">()</span></span> &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">off</span><span class="hljs-params">()</span></span> &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 索尼电视</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SonyTVController</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">on</span><span class="hljs-params">()</span></span> &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">off</span><span class="hljs-params">()</span></span> &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// TCL 电视</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TclTVController</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">on</span><span class="hljs-params">()</span></span> &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">off</span><span class="hljs-params">()</span></span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是针对每一个电视机品牌都需要编写开机和关机的函数实在是过于麻烦，而借助泛型，就可以实现“万能遥控”：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 尖括号中的 MiTVController 为泛型实参</span><br>    TvController&lt;MiTV&gt;().on(MiTV())<br>&#125;<br><br><span class="hljs-comment">// T 为泛型形参</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TvController</span>&lt;<span class="hljs-type">T</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">on</span><span class="hljs-params">(tv: <span class="hljs-type">T</span>)</span></span> &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">off</span><span class="hljs-params">(tv: <span class="hljs-type">T</span>)</span></span> &#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MiTV</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SonyTV</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TclTV</span><br></code></pre></td></tr></table></figure><p>泛型的形参<code>T</code>代表了可以传入任意类型，借助这个特性，无论是什么品牌的电视，都可以用这个遥控器来实现开关机。</p><p>泛型的形参也可以进行范围限制，例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    TvController&lt;MiTV&gt;().on(MiTV())<br>&#125;<br><br><span class="hljs-comment">// 在形参中添加上界</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TvController</span>&lt;<span class="hljs-type">T : TV</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">on</span><span class="hljs-params">(tv: <span class="hljs-type">T</span>)</span></span> &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">off</span><span class="hljs-params">(tv: <span class="hljs-type">T</span>)</span></span> &#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TV</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MiTV</span> : <span class="hljs-type">TV</span>()<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SonyTV</span> : <span class="hljs-type">TV</span>()<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TclTV</span> : <span class="hljs-type">TV</span>()<br></code></pre></td></tr></table></figure><p>以上代码修改了<code>TvController</code>的形参，这样一来，<code>TvController</code>就只能接收<code>TV</code>类的子类，这叫做泛型的上界。</p><p>除了类能使用泛型，Kotlin 中的函数也能使用泛型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    turnOnTV(MiTV())<br>&#125;<br><br><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TV</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MiTV</span> : <span class="hljs-type">TV</span>()<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : TV&gt;</span> <span class="hljs-title">turnOnTV</span><span class="hljs-params">(tv: <span class="hljs-type">T</span>)</span></span> &#123;<br>    println(<span class="hljs-string">&quot;打开电视&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="泛型不变性"><a href="#泛型不变性" class="headerlink" title="泛型不变性"></a>泛型不变性</h3><p>假设一个类是另一个类的子类，那么这个类的集合和它父类的集合之间是什么关系呢：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    foo(mutableListOf(Animal()))  <span class="hljs-comment">// 报错，传入类型错误</span><br>    bar(mutableListOf(Cat()))<br>&#125;<br><br><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> : <span class="hljs-type">Animal</span>()<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> : <span class="hljs-type">Animal</span>()<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">(list: <span class="hljs-type">MutableList</span>&lt;<span class="hljs-type">Cat</span>&gt;)</span></span> &#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar</span><span class="hljs-params">(list: <span class="hljs-type">MutableList</span>&lt;<span class="hljs-type">Animal</span>&gt;)</span></span> &#123;<br>    list.add(Dog())<br>    <span class="hljs-keyword">val</span> firstAnimal: Dog = list.first()  <span class="hljs-comment">// 报错，父类无法转成子类</span><br>&#125;<br></code></pre></td></tr></table></figure><p>结论是没什么关系，它们之间也无法替代对方，这就是泛型的不变性。泛型的不变性保证了程序上不会出现一些逻辑性错误。</p><h3 id="协变（Covariant）"><a href="#协变（Covariant）" class="headerlink" title="协变（Covariant）"></a>协变（Covariant）</h3><p>众所周知，在代码中，是可以往需要父类对象的地方传入子类对象的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    test(Son())  <span class="hljs-comment">// 需要传入 Father 类，但是却传入了 Son 类，也没问题</span><br>&#125;<br><br><span class="hljs-comment">// 父类</span><br><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span><br><br><span class="hljs-comment">// 子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-type">Father</span>()<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(father: <span class="hljs-type">Father</span>)</span></span> &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>那么在需要父类泛型的地方可以传入子类泛型吗？根据前面提到的泛型的不变性，两者间并不存在什么关系，所以这样做，编译器会报错：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    test(Foo&lt;Son&gt;())  <span class="hljs-comment">// 报错，需要传父类泛型，但是却传了子类泛型</span><br>&#125;<br><br><span class="hljs-comment">// 父类</span><br><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span><br><br><span class="hljs-comment">// 子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-type">Father</span>()<br><br><span class="hljs-comment">// 泛型类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>&lt;<span class="hljs-type">T</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span> &#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用泛型类的函数</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(foo: <span class="hljs-type">Foo</span>&lt;<span class="hljs-type">Father</span>&gt;)</span></span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>可是在某些特殊场景下确实是要这么做，那应该怎么让编译器通过编译呢，这时候就可以使用到泛型的 <strong>协变</strong> ，协变可以在使用处或者是声明处使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 使用处协变</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(foo: <span class="hljs-type">Foo</span>&lt;<span class="hljs-type">out</span> <span class="hljs-type">Father</span>&gt;)</span></span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>或者：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 声明处协变</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>&lt;<span class="hljs-type">out T</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样一来，就可以在需要父类泛型的地方传入子类泛型了。Kotlin 中使用<code>out</code>来表示协变，对应 Java 中的<code>extends</code>。</p><h3 id="逆变（Contravariant）"><a href="#逆变（Contravariant）" class="headerlink" title="逆变（Contravariant）"></a>逆变（Contravariant）</h3><p>协变会让父类的泛型与子类的泛型之间产生类似于父类本身与子类本身之间的关系（也就是需要父类的地方可以传入子类），而逆变就是让这个关系反过来：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    test(Foo&lt;Father&gt;())  <span class="hljs-comment">// 报错，需要传子类泛型，但是却传了父类泛型</span><br>&#125;<br><br><span class="hljs-comment">// 省略中间这部分代码</span><br><br><span class="hljs-comment">// 使用泛型类的函数</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(foo: <span class="hljs-type">Foo</span>&lt;<span class="hljs-type">Son</span>&gt;)</span></span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>同样是在使用处或者是声明处，添加<code>in</code>关键字就可以解决编译问题：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 使用处协变</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(foo: <span class="hljs-type">Foo</span>&lt;<span class="hljs-type">in</span> <span class="hljs-type">Son</span>&gt;)</span></span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 声明处协变</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>&lt;<span class="hljs-type">in T</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Kotlin 中使用<code>in</code>来表示逆变，对应 Java 中的<code>super</code>。</p><p>那么该如何记忆协变对应<code>out</code>，逆变对应<code>in</code>呢，我觉得可以这样理解：in 的意思是在什么的里面，子类往往是父类的扩展（父类有的子类都有，子类有的父类不一定有），所以如果画图来表示的话，父类是被“包含”在子类里面的，所以当遇到<code>&lt;in T&gt;</code>时，我们就可以知道，这个地方可以传入 T 的父类。因为“T 的父类 in T”。</p><h3 id="星投影（Star-Projections）"><a href="#星投影（Star-Projections）" class="headerlink" title="星投影（Star-Projections）"></a>星投影（Star-Projections）</h3><p>Kotlin 可以使用星号<code>*</code>来作为泛型的实参：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    bar(Foo&lt;<span class="hljs-built_in">Int</span>&gt;())  <span class="hljs-comment">// 可以传入整型</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>&lt;<span class="hljs-type">T</span>&gt;<br><br><span class="hljs-comment">// 使用星投影</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar</span><span class="hljs-params">(foo: <span class="hljs-type">Foo</span>&lt;*&gt;)</span></span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><code>Foo</code>类在声明形参时使用了<code>T</code>，代表了这是个泛型，并不关心传入什么类型进来。然而<code>bar()</code>在使用泛型的时候在实参中使用了<code>*</code>，也是代表它并不关心传入什么类型，把最终的决定权放在了调用<code>bar()</code>的地方，所以在<code>main()</code>中就直接传入了整型。也就是说，星投影是在我们不关心实参到底是什么的时候就可以使用。</p><p>要想稍加限制也可以，只要在形参处进行限制就行了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// bar(Foo&lt;String&gt;())  // 报错</span><br>    bar(Foo&lt;MyActivity&gt;())<br>&#125;<br><br><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>&lt;<span class="hljs-type">T : Activity</span>&gt;  // 传进来的参数需要是 <span class="hljs-title">Activity</span> 类或者是它的子类<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyActivity</span> : <span class="hljs-type">Activity</span>() &#123;<br><br>&#125;<br><br><span class="hljs-comment">// 使用星投影</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar</span><span class="hljs-params">(foo: <span class="hljs-type">Foo</span>&lt;*&gt;)</span></span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这样一来，虽然<code>bar()</code>选择摆烂，但是真正在调用<code>bar()</code>传参数的时候，还是会收到<code>Foo</code>类的约束。</p><h3 id="in-还是-out-？"><a href="#in-还是-out-？" class="headerlink" title="in 还是 out ？"></a>in 还是 out ？</h3><p>前面稍微提到了如何记忆和使用 in 与 out ，不过实际上也没有那么复杂，无论是 Java 还是 Kotlin 的泛型，都提到了另外两个词：生产者和消费者。前者对应 out ，而后者对应 in 。</p><p>用通俗的话来说，被 in 修饰的泛型，往往会以函数的参数的形式，被传入函数里面，这是一种写入行为。而被 out 修饰的泛型，往往会以返回值的形式，被函数返回，这是一种读取行为。总的来说，传入用 in ，传出用 out ，泛型作为参数的时候用 in ，泛型作为返回值的时候用 out 。接下来看一下 Kotlin 官方的用例吧：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparable</span>&lt;<span class="hljs-type">in T</span>&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(other: <span class="hljs-type">T</span>)</span></span>: <span class="hljs-built_in">Int</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterator</span>&lt;<span class="hljs-type">out T</span>&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">next</span><span class="hljs-params">()</span></span>: T<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="注解与反射"><a href="#注解与反射" class="headerlink" title="注解与反射"></a>注解与反射</h2><p>泛型提高了代码的复用性，注解与反射则是提高了代码的灵活性。</p><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>注解可以理解为对程序代码的一种补充，最常见的注解，例如 Java 中的<code>@Override</code>代表重写，以及<code>@Deprecated</code>代表了函数被弃用，以及 Jetpack Compose 中的<code>@Composable</code>代表了定义一个可组合项。</p><p>那么什么是“元注解”呢，在<code>@Deprecated</code>中可以看到，在<code>Deprecated</code>类的上面还有<code>@Target</code>和<code>@MustBeDocumented</code>，像这种本身既是注解，又可以修饰其它注解的就是元注解。</p><p>Kotlin 常见的元注解有四个：</p><ul><li><code>@Target</code>：指定了被修饰的注解可以用在什么地方，也就是目标。</li><li><code>@Retention</code>：指定了被修饰的注解是否编译后可见、是否运行时可见，也就是注解的保留位置，是保留在编译时还是运行时。</li><li><code>@Repeatable</code>：允许在同一个地方多次使用相同的被修饰的注解，使用场景比较少。</li><li><code>@MustBeDocumented</code>：指定被修饰的注解应该在生成的 API 文档中显示，这个注解一般用于 SDK 当中。</li></ul><p>其中<code>@Target</code>有很多可取值，代表了它可以用来修饰什么：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnnotationTarget</span> &#123;<br>    <span class="hljs-comment">/** Class, interface or object, annotation class is also included */</span><br>    CLASS,<br>    <span class="hljs-comment">/** Annotation class only */</span><br>    ANNOTATION_CLASS,<br>    <span class="hljs-comment">/** Generic type parameter */</span><br>    TYPE_PARAMETER,<br>    <span class="hljs-comment">/** Property */</span><br>    PROPERTY,<br>    <span class="hljs-comment">/** Field, including property&#x27;s backing field */</span><br>    FIELD,<br>    <span class="hljs-comment">/** Local variable */</span><br>    LOCAL_VARIABLE,<br>    <span class="hljs-comment">/** Value parameter of a function or a constructor */</span><br>    VALUE_PARAMETER,<br>    <span class="hljs-comment">/** Constructor only (primary or secondary) */</span><br>    CONSTRUCTOR,<br>    <span class="hljs-comment">/** Function (constructors are not included) */</span><br>    FUNCTION,<br>    <span class="hljs-comment">/** Property getter only */</span><br>    PROPERTY_GETTER,<br>    <span class="hljs-comment">/** Property setter only */</span><br>    PROPERTY_SETTER,<br>    <span class="hljs-comment">/** Type usage */</span><br>    TYPE,<br>    <span class="hljs-comment">/** Any expression */</span><br>    EXPRESSION,<br>    <span class="hljs-comment">/** File */</span><br>    FILE,<br>    <span class="hljs-comment">/** Type alias */</span><br>    <span class="hljs-meta">@SinceKotlin(<span class="hljs-string">&quot;1.1&quot;</span>)</span><br>    TYPEALIAS<br>&#125;<br></code></pre></td></tr></table></figure><p>同样在<code>@Retention</code>中的取值也值得注意：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnnotationRetention</span> &#123;<br>    <span class="hljs-comment">/** Annotation isn&#x27;t stored in binary output */</span><br>    <span class="hljs-comment">/** 注解只存在于源代码，编译后不可见 */</span><br>    SOURCE,<br>    <span class="hljs-comment">/** Annotation is stored in binary output, but invisible for reflection */</span><br>    <span class="hljs-comment">/** 注解编译后可见，运行时不可见 */</span><br>    BINARY,<br>    <span class="hljs-comment">/** Annotation is stored in binary output and visible for reflection (default retention) */</span><br>    <span class="hljs-comment">/** 注解编译后可见，运行时可见 */</span><br>    RUNTIME<br>&#125;<br></code></pre></td></tr></table></figure><p>那么该如何使用注解，以<code>@Deprecated</code>修饰函数为例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Deprecated(</span><br><span class="hljs-meta">    message = <span class="hljs-string">&quot;请使用 newFoo() 代替&quot;</span>,</span><br><span class="hljs-meta">    replaceWith = ReplaceWith(<span class="hljs-string">&quot;newFoo()&quot;</span>),</span><br><span class="hljs-meta">    level = DeprecationLevel.ERROR</span><br><span class="hljs-meta">)</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">oldFoo</span><span class="hljs-params">()</span></span> &#123;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">newFoo</span><span class="hljs-params">()</span></span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这里定义了两个函数，我们假装<code>oldFoo()</code>是过时的函数，需要用<code>newFoo()</code>来代替它，所以我们使用了<code>@Deprecated</code>来修饰<code>oldFoo()</code>，并补充了 3 个参数，包括关于废弃它的信息，以及应该用什么函数来代替，以及使用这个废弃的函数的严重程度。关于第 3 个参数，在这里定义的是<code>DeprecationLevel.ERROR</code>，这就代表使用这个函数会被编译器视为错误，从而无法通过编译。而当鼠标移到<code>oldFoo()</code>的调用处上面时，IDE 还会提供快速修复选项（如果有定义的话），在这里就是将<code>oldFoo()</code>替换成<code>newFoo()</code>。</p><p>Kotlin 的注解还有一个细节就是注解的精确使用目标，例如在使用依赖注入框架时，如果去标记一个被<code>var</code>修饰的属性，那么编译器会报错，因为被<code>var</code>修饰的属性包含了属性背后的字段、getter、setter 三个含义，如果不明确标记其中之一，编译器根本不知道该怎么做。例如使用 Dagger ，要标记 setter ，那么只需要在属性上方插入：<code>@set:Inject</code>即可。除了 set 以外，Kotlin 当中还有其它的使用目标：</p><ul><li>file：作用于文件</li><li>property：作用于属性</li><li>field：作用于字段</li><li>get：作用于属性 getter</li><li>set：作用于属性 setter</li><li>receiver：作用于扩展的接受者参数</li><li>param：作用于构造函数参数</li><li>setparam：作用于函数参数</li><li>delegate：作用于委托字段</li></ul><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>Kotlin 反射具备这三个特质：</p><ul><li>感知程序的状态，包含程序的运行状态和源代码结构。</li><li>修改程序的状态。例如修改某个变量，即使这个变量是被<code>private</code>或者<code>final</code>修饰的。</li><li>根据程序的状态调整自身的决策行为。例如 JSON 解析经常会用到<code>@SerializedName</code>这个注解，如果属性有<code>@SerializedName</code>修饰的话，解析时就会以指定的名称为准，如果没有，那就直接使用属性的名称来解析。</li></ul><p>来看一个感知程序状态的简单案例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> kotlin.reflect.full.functions<br><span class="hljs-keyword">import</span> kotlin.reflect.full.memberProperties<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    readMembers(Student(<span class="hljs-string">&quot;Aiden&quot;</span>, <span class="hljs-number">23</span>))<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>) &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span> &#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">readMembers</span><span class="hljs-params">(obj: <span class="hljs-type">Any</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 打印属性</span><br>    obj::<span class="hljs-keyword">class</span>.memberProperties.forEach &#123;<br>        println(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;obj::class.simpleName&#125;</span>.<span class="hljs-subst">$&#123;it.name&#125;</span> = <span class="hljs-subst">$&#123;it.getter.call(obj)&#125;</span>&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// 打印函数</span><br>    obj::<span class="hljs-keyword">class</span>.functions.forEach &#123;<br>        println(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;it.name&#125;</span>()&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果是：</p><blockquote><p>Student.age &#x3D; 23<br>Student.name &#x3D; Aiden<br>study()<br>equals()<br>hashCode()<br>toString()</p></blockquote><ul><li><code>readMembers()</code>接收了一个<code>Any</code>类型的参数，也就是任何类都可以通过反射来获取成员属性和函数。</li><li><code>obj::class</code>叫类引用，是 Kotlin 反射的语法，通过该语法就可以拿到一个<code>KClass</code>接口，通过这个接口间接拿到实际的类的成员信息。</li><li>通过调用<code>memberProperties</code>就可以拿到类的属性的集合，在这里利用<code>forEach</code>遍历集合就拿到了<code>Student</code>类中的<code>name</code>属性和<code>age</code>属性。值得补充的是，<code>memberProperties</code>是<code>KClass</code>的扩展属性，定义于 Kotlin 的反射库中（需要在 Gradle 中引入这个库），而<code>KClass</code>是默认存在于标准库中的，也就是说，要想使用完整的反射，需要引入反射库。</li><li>调用<code>memberProperties</code>返回的是一个集合：<code>Collection&lt;KProperty1&lt;T, *&gt;&gt;</code>，<code>KClass</code>代表的是类的反射，而<code>KProperty1</code>就代表的是属性的反射了，通过调用<code>KProperty1.name</code>就可以拿到属性的名称，然后调用<code>KProperty1.getter.call()</code>就可以获取属性的值。另外这里的<code>getter</code>实际上是<code>KProperty1</code>中的属性，是<code>Getter&lt;T, out V&gt;</code>类型，而它又实现了<code>KProperty.Getter&lt;out V&gt;</code>接口，而它又实现了<code>KFunction&lt;out R&gt;</code>接口，而它又实现了<code>KCallable&lt;out R&gt;</code>，这就是可以调用<code>call()</code>的原因。</li></ul><p>接下来是一个修改属性值的案例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    changeName(Student(<span class="hljs-string">&quot;Aiden&quot;</span>, <span class="hljs-number">23</span>))<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">var</span> name: String, <span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">changeName</span><span class="hljs-params">(obj: <span class="hljs-type">Any</span>)</span></span> &#123;<br>    obj::<span class="hljs-keyword">class</span>.memberProperties.forEach &#123;<br>        <span class="hljs-keyword">if</span> (it.getter.call(obj) == <span class="hljs-string">&quot;Aiden&quot;</span> &amp;&amp; it <span class="hljs-keyword">is</span> KMutableProperty1 &amp;&amp; it.setter.parameters.size == <span class="hljs-number">2</span> &amp;&amp; it.getter.returnType.classifier == String::<span class="hljs-keyword">class</span>) &#123;<br>            it.setter.call(obj, <span class="hljs-string">&quot;Marcus&quot;</span>)<br>            println(it.getter.call(obj))<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果是：</p><blockquote><p>Marcus</p></blockquote><ul><li>在<code>changeName()</code>中遍历属性，并通过反射进行各种判断，包括但不限于：<ul><li>通过<code>it.getter.call(obj) == &quot;Aiden&quot;</code>判断属性的值是否为<code>Aiden</code>；</li><li>通过<code>it is KMutableProperty1</code>判断这个属性是否被<code>var</code>修饰；</li><li>通过<code>it.setter.parameters.size == 2</code>判断如果要修改这个属性的话需要传几个参数，在这里是两个参数，一个是 obj 本身，另一个是新值；</li><li>通过<code>it.getter.returnType.classifier == String::class</code>判断属性的返回值是否为<code>String</code>类型。</li></ul></li><li>接着通过<code>setter.call()</code>来修改属性值。不过在调用这个函数前还需要用<code>it is KMutableProperty1</code>来判断属性是否可被修改，否则就调用不了<code>setter</code>。</li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>学习使用 Git</title>
    <link href="/posts/Git-Study-Guide/"/>
    <url>/posts/Git-Study-Guide/</url>
    
    <content type="html"><![CDATA[<p>Git 属于「分布式版本管理系统」，其特点在于克隆仓库时，会顺带将版本历史一同克隆，所以假设云端的仓库发生了修改，那么在本地的仓库进行同步操作的时候，云端的改动也会应用到本地当中，同时版本历史也记录着这些改动，并且这些改动可以被还原（例如恢复被删除的文件）。</p><span id="more"></span><p>「分布式」体现在每一个克隆了仓库的开发者都可以单独对版本进行管理，并且不需要与互联网连接就可以执行 commit 操作。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell">git clone<br></code></pre></td></tr></table></figure><p>用于将仓库克隆到本地。</p><p>用例：</p><ul><li><code>git clone git@github.com:username/repositoryName.git myRepository</code>：将<code>username</code>用户的<code>repositoryName</code>仓库克隆到当前目录到<code>myRepository</code>文件夹下，其中<code>myRepository</code>是一个指定文件夹的操作，可以省略不写，不写的话默认以仓库名作为文件夹名称，然后克隆到这个文件夹中。</li></ul><h3 id="log"><a href="#log" class="headerlink" title="log"></a>log</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell">git log<br></code></pre></td></tr></table></figure><p>查看 commits 历史，其中新的 commit 始终打印在屏幕上边。一个 commit 记录大概长这样：</p><blockquote><p>commit sc872s0vvke49ee6a7bac1952a6c5942b1195a11 (HEAD -&gt; main, origin&#x2F;main, origin&#x2F;HEAD)<br>Author: Aiden Lin <a href="mailto:&#x65;&#120;&#97;&#109;&#x70;&#108;&#101;&#64;&#121;&#x61;&#104;&#111;&#x6f;&#x2e;&#x63;&#111;&#x6d;">example@yahoo.com</a><br>Date:   Fri Feb 3 12:00:00 2023 +0800</p><p>Initial commit</p></blockquote><p>一个记录大致涵盖了几条信息，首先<code>11867c9dfce49ee6a7bac1952a6c5942b1195a11</code>是这个 commit 的哈希值，往下是这次 commit 的提交者和他的邮箱，以及提交日期，最后是这次 commit 的备注。而在哈希值的右边，<code>HEAD</code>代表了一个指针，其往往会指向最新一次的 commit 。除了指针，分支也算是引用的一种，例如<code>main</code>分支，其可以指向一个 commit ，也可以被<code>HEAD</code>指向，实际中往往是后者。</p><p>如果仓库中存在多个分支，那么在查看记录的时候可以通过添加参数<code>--graph</code>来生成友好的图形化打印，由此可以更加清晰地查看提交情况。</p><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell">git add<br></code></pre></td></tr></table></figure><p>用例：</p><ul><li><code>git add README.md</code>：将 README.md 添加到暂存区（staging area），在 commit 时会将该文件的改动提交。</li><li><code>git add .</code>：将所有文件添加到缓存区，在 commit 时会将改动提交。</li></ul><h3 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell">git commit<br></code></pre></td></tr></table></figure><p>将暂存区的文件的改动进行提交，回车后会出现允许输入文本的区域，此时输入的内容将作为本次 commit 的备注（就是用于说明本次提交做了什么改动，此为可选操作）。</p><p>用例：</p><ul><li><code>git commit -m &#39;修复了 BUG&#39;</code>：提交这次的修改，并且为其添加备注：“修复了 BUG”。</li></ul><h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell">git push<br></code></pre></td></tr></table></figure><p>将所有 commits 推送到云端的仓库。</p><p>用例：</p><ul><li><code>git push origin main</code>：其中<code>origin</code>为云端仓库的默认名称，<code>main</code>是需要上传到的分支的名称。</li></ul><h3 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell">git pull<br></code></pre></td></tr></table></figure><p>将云端仓库拉取到本地，为了同步别人的改动，或者是保持仓库的最新状态。</p><p>用例：</p><ul><li><code>git pull origin main</code>：其中<code>origin</code>为云端仓库的名称，<code>main</code>是需要拉取的分支的名称。</li></ul><p><code>git pull</code>实际上由两步操作组成，分别是<code>git fetch</code>和<code>git merge</code>，git 首先会执行 fetch 操作将云端仓库的镜像（<code>origin/main</code>、<code>origin/HEAD</code>等）同步到本地，接着再把这些镜像所指向的 commit 同步到本地，这样 fetch 的操作就完成了。而 merge 的工作则是调整本地的分支和 HEAD 指针的指向，让它们指向和镜像相同的 commit ，这样就能保持本地和云端同步了。</p><p>不过还需要注意，对于这条命令<code>git pull origin main</code>来说，在执行 merge 的时候，git 只会调整本地的 main 分支，使其与云端镜像保持同步，但是假设云端仓库和本地仓库都存在名为 feature1 的分支，并且云端和本地的 feature1 分支的 commits 并不相同，那么在 pull 的时候，对于 feature1 来说，只会执行 fetch 而不执行 merge ，也就是云端的 feature1 是不会自动和本地的 feature1 merge 的。</p><h3 id="分支相关"><a href="#分支相关" class="headerlink" title="分支相关"></a>分支相关</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Shell">git branch<br>git checkout<br>git merge<br></code></pre></td></tr></table></figure><p>创建、切换、合并分支。</p><p>用例：</p><ul><li><code>git branch feature1</code>：创建一个名为<code>feature1</code>的分支，这个分支默认指向最新的 commit ，创建好的分支可以在<code>git log</code>中查看到。</li><li><code>git checkout feature1</code>：切换到<code>feature1</code>分支。另外此时在<code>git log</code>中可以看到，<code>HEAD</code>指针从原来指向<code>main</code>分支变成了指向<code>feature1</code>分支。</li><li><code>git merge feature1</code>：在执行这个操作前，需要先执行切换分支的操作，以保证当前所在分支不是被合并的分支（不是<code>feature1</code>），例如先切换到<code>main</code>分支，然后再执行。在合并分支时会出现几种情况，最理想的一种是「Fast-forward」，也就是被合并的分支的开发进度领先于主分支，合并的结果就是主分支的指针直接指向被合并的分支所指向的 commit 就行了。</li><li><code>git branch -d feature1</code>：删除<code>feature1</code>分支。</li></ul><h3 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell">git reset<br></code></pre></td></tr></table></figure><p>将仓库恢复到某个 commit 的状态。</p><p>用例：</p><ul><li><code>git reset --hard abcdef</code>：恢复到 commit 的哈希值为<code>abcdef</code>的状态。</li></ul><h3 id="status"><a href="#status" class="headerlink" title="status"></a>status</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell">git status<br></code></pre></td></tr></table></figure><p>查看当前分支的改动状态，包括位于暂存区（staging area）的和修改了但是还没有添加到暂存区的。具体来说，假设在<code>README.md</code>中默认有这样的内容：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># Learn-Git</span><br>some text<br></code></pre></td></tr></table></figure><p>在没有改动的情况下执行<code>git status</code>会得到如下结果：</p><blockquote><p>无文件要提交，干净的工作区</p></blockquote><p>随后对文件进行修改：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># Learn-Git</span><br>some text<br><br>More text<br></code></pre></td></tr></table></figure><p>此时执行<code>git status</code>会得到如下结果：</p><blockquote><p>尚未暂存以备提交的变更：<br>（使用 “git add &lt;文件&gt;…” 更新要提交的内容）<br>（使用 “git restore &lt;文件&gt;…” 丢弃工作区的改动）<br>修改：     README.md</p><p>修改尚未加入提交（使用 “git add” 和&#x2F;或 “git commit -a”)</p></blockquote><p>可以看到 git 已经探测了改动，并且<code>修改：     README.md</code>这一行文字将以 <strong>红色</strong> 字体展示，此时执行<code>git add README.md</code>将改动提交到暂存区，然后再执行<code>git status</code>会得到如下结果：</p><blockquote><p>要提交的变更：<br>（使用 “git restore –staged &lt;文件&gt;…” 以取消暂存）<br>修改：     README.md</p></blockquote><p>此时<code>修改：     README.md</code>将以 <strong>绿色</strong> 字体展示。此时再次修改文件：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># Learn-Git</span><br>some text<br><br>More text<br><br>some code<br></code></pre></td></tr></table></figure><p>再执行<code>git status</code>会得到如下结果：</p><blockquote><p>要提交的变更：<br>（使用 “git restore –staged &lt;文件&gt;…” 以取消暂存）<br>修改：     README.md</p><p>尚未暂存以备提交的变更：<br>（使用 “git add &lt;文件&gt;…” 更新要提交的内容）<br>（使用 “git restore &lt;文件&gt;…” 丢弃工作区的改动）<br>修改：     README.md</p></blockquote><p>上面的<code>修改：     README.md</code>以 <strong>绿色</strong> 字体展示，下面的则以 <strong>红色</strong> 字体展示。由此得知，git 可以探测到文件的改动，并且未被添加到暂存区的改动，git 将以 <strong>红色</strong> 字体进行提示，而提交到暂存区但是没有进行 commit 的改动，git 将以 <strong>绿色</strong> 字体进行提示。进一步说，<code>git add</code>针对的是改动而不是文件，每一次「add」实际上是将该文件的这一次改动添加到暂存区，而不是说将整个文件添加到暂存区。</p><h2 id="Feature-Branching"><a href="#Feature-Branching" class="headerlink" title="Feature Branching"></a>Feature Branching</h2><p>所谓「Feature Branching」即是在不影响主分支代码的情况下进行开发，也就是为需要开发的新功能创建一条新分支，然后在这条分支上编写代码，这样一来，无论开发完成与否，都不会影响到主分支的代码。</p><h3 id="本地合并"><a href="#本地合并" class="headerlink" title="本地合并"></a>本地合并</h3><p>当功能开发完毕，需要合并代码时，一般有两种做法，第一种就是在本地合并，然后推向云端仓库。具体来说，就是先切换到主分支，然后<code>git pull</code>……对，不是立刻<code>git merge</code>，而是先 pull 一下云端仓库，以此保证主分支的同步，然后再在本地 merge 分支，最后再推向云端仓库。这么做没什么大问题，主要是在 push 之前有可能会发生主分支又被别人以迅雷不及掩耳之势修改从而导致不能「Fast-forward」也就是会导致 push 失败……如果真的是这样，那就只能再 pull 一次，然后再 push ，如此反复。</p><h3 id="基于-GitHub"><a href="#基于-GitHub" class="headerlink" title="基于 GitHub"></a>基于 GitHub</h3><p>第二种做法则是基于 GitHub 中的「pull request」来实现，这种做法就不需要在本地 merge ，而是直接把分支推送到云端仓库。例如现在有一个分支名为「feature1」，那么在开发完成后，就直接<code>git push origin feature1</code>，此时在仓库的网页页面顶部就会出现一个提示：<img src="/../../images/Notes/feature1-had-recent-pushes.png" alt="feature1 已被推送"></p><p>而在提示右边的「Compare &amp; pull request」按钮将会在云端合并分支时用到，点击按钮就会进入到一个「Open a pull request」的页面，在这个页面中可以写一些关于本次更新的说明，然后点击右下角的「Create pull request」按钮来创建一个 pull request 。pull request 在创建好以后，可以在右边的边栏中添加「Reviewers」，让他们对本次更新进行检查。此外还可以添加「Labels」，以确定本次更新的主题。</p><p>pull request 创建好以后，Reviewers 可能会提出一些建议，基于这些建议，需要在本地对代码进行修改，修改完成后，只需要再次<code>git push origin feature1</code>，改动就会被推送到 pull request 中，Reviewers 可以立刻看到这些 commits 。如果没什么问题了，就可以点击下方的「Merge pull request」按钮来合并分支，然而这是个「drop down menu」，点击后提供了 3 个选项：</p><ul><li><code>Create a merge commit</code>（All commits from this branch will be added to the base branch via a merge commit.）：这是默认选项，会将该分支下所有的 commits 合并到主分支中。需要注意的是，GitHub 在合并的时候添加了<code>--no-ff</code>参数，该参数表示不使用「Fast-forward」特性，所以在合并后，会在顶部额外产生一个新的 commit ，这个 commit 的标题和描述就是在按下「Merge pull request」按钮后填写的内容。</li></ul><p><img src="/../../images/Notes/merge-description.png" alt="填写这次 merge commit 的信息"></p><p><img src="https://docs.github.com/assets/cb-5407/images/help/pull_requests/standard-merge-commit-diagram.png" alt="Create a merge commit 示意图"></p><ul><li><code>Squash and merge</code>（The x commits from this branch will be combined into one commit in the base branch.）：将分支上的所有 commits 压缩成一个 commit 然后 merge 到主分支中，merge 采用「Fast-forward」选项。</li></ul><p><img src="https://docs.github.com/assets/cb-5742/images/help/pull_requests/commit-squashing-diagram.png" alt="Squash and merge 示意图"></p><ul><li><code>Rebase and merge</code>（The x commits from this branch will be rebased and added to the base branch.）：将分支上的 commits 逐一添加到主分支上，并且不会额外生成 commit 。</li></ul><p>最后，在云端仓库完成了合并以后，本地也需要合并，只不过是使用<code>git pull</code>来合并，而不是<code>git merge</code>了。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>我真的好喜欢云芝小姐</title>
    <link href="/posts/I-really-love-Miss-Yunzhi-so-much/"/>
    <url>/posts/I-really-love-Miss-Yunzhi-so-much/</url>
    
    <content type="html"><![CDATA[<p>今天浅谈一下我对动画《斗破苍穹：三年之约》的初印象（标题说我喜欢云芝，其实美杜莎老婆我也很喜欢哈哈哈哈）。</p><span id="more"></span><p>有些话不吐露出来，有些感情不表达出来，我可能真的会夜不能寐食不甘味。《斗破苍穹》出第一季动画的时候我在上高中，当时是在坐公交车去学校的路上用手机看的，只不过当时因为资源的问题，第 12 集没看到，加之第一季的质量确实比较一般，后来也就不了了之了。</p><p>前段时间在找片子看，无意中看到斗破苍穹已经更新到第四季了……于是乎找了个渠道稍微看了一下，不看不要紧，这一看，确实是发现从第一季特别篇开始整部动画有了质的飞跃（因为换了制作方）。而也就是这短短一个小时不到的时间，直接拉高了我对整部动画的兴趣以及对后续剧情发展的期待。然而我有个坏习惯，对于感兴趣的片子，我会用快进的方式把后面没来得及看的剧集快速过一遍。紧接着问题就来了，昨天晚上没忍住，快进看完了《三年之约》，从九点半一直看到 12 点，看了个大概。只能说尽管只有短短 13 集，但无论是建模、画面、特效、剧情、音乐、配音任何一个层面，都让我觉得很满意。虽然三年之约这一部分的小说我也读过（应该吧，差不多十年前上初中那会儿的事情，早忘了），但是动画相比小说和漫画又有着它独特的表达方式，加之剧情中频频不断出现的高手和萧炎一张又一张的底牌实在是让我过足了瘾。</p><p>这几个小时下来，唯有一处地方真是让我又爱又恨，那便是萧炎和云芝的关系。爱，是爱云芝。恨，是恨老天将云芝和萧炎如此戏剧般地安排。云芸作为一宗之主，需要担起相应的责任，但偏偏是这样一个人，却在魔兽山脉和塔戈尔沙漠和萧炎发生了那样的儿女情长，云芸和云芝的矛盾在动画中被体现得淋漓尽致。有的人说，云芝理论上不应该有现在这么高的人气，之所以有，那也得多亏了制作方的高质量建模和杨梦露老师为其注入灵魂。小说和漫画我都没看完我就不做评价了，但是就现阶段而言，我相信动画版的云芝是俘获了包括我在内很多观众的心的。</p><p>所以说我真的服了这个老六剧组，从第一季特别篇开始就一直给观众发刀片，从特别篇第一集刀到三年之约最后一集还不肯放过我。尤其是那首 AZA 微唱团的《从别后》，每次一到萧炎和云芝的感情戏，这首歌曲就会作为背景音乐响起，每次一听到这个旋律我就一股伤感油然而生，听多了以后搞得我都有生理反应了，现在一听到这首歌我就鼻子发酸眼角湿润，脑子里全是云芝的样子和声音。在被云芝迷住的这段时间里，整天都无精打采萎靡不振，做事的时候心不在焉，看来只有时间能让我的这种症状慢慢缓解了……云芝你带我走吧，没有你我怎么活啊云芝！</p><p>总而言之，《斗破苍穹》的小说和漫画是我初中生活的一部分，如今看到它的动画作品的质量也能如此之高，开心之中夹带着欣慰，真心希望这个系列能够保持如此的质量水平甚至是突破至更高的质量持续连载下去直到完结，青史留名，也是给斗破苍穹粉丝最好的礼物。</p><p>不得不说：</p><blockquote><p>我现在对第五季动画的期待比 R 星出 GTA6 还高。</p></blockquote><p><img src="/../../images/ACGN/Yunzhi.jpg" alt="云芝"></p>]]></content>
    
    
    <categories>
      
      <category>ACGN</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>真的有人觉得《租借女友》好看吗？</title>
    <link href="/posts/Review-Kanojo-Okarishimasu/"/>
    <url>/posts/Review-Kanojo-Okarishimasu/</url>
    
    <content type="html"><![CDATA[<p>这仍然是一部不能带脑子去认真看的番。</p><span id="more"></span><p>开头看着还行，看到第七集的时候，结合了前面的内容梳理了一下，实在是有些没绷住。后来看到第八集以后更是让我难以接受，整集都是倍速过去的，最后在 5 月 12 日终于把这坨屎吃完了。</p><h2 id="先说说男主"><a href="#先说说男主" class="headerlink" title="先说说男主"></a>先说说男主</h2><p>男主真的挺奇怪的，被前女友甩了就算了，还要想着去租女友，这究竟是为了什么？是为了在别人面前炫耀不属于自己的东西来满足虚荣心？是为了让自己尽快从被甩了的阴影中走出？是为了哄奶奶开心？租来了女友，达成了哄奶奶的目的，且不说完事了以后不仅不撇清与租借女友的交易关系，反而还喜欢上了人家。然后第七集突然杀出来一个各方面都挺不错并且对自己持有好感的女孩子对自己表白了，眼看此时自己终于有机会摆脱单身了，结果这男主还不乐意了，还开始挑剔了。当然，恋爱是双向的，男主有权拒绝，他没做错，只不过我作为观众，看到这样的展开很不爽，所以我也要吐槽吐槽。</p><h2 id="再说说前女友"><a href="#再说说前女友" class="headerlink" title="再说说前女友"></a>再说说前女友</h2><p>前女友这个角色我觉得塑造得很成功，因为在我眼里，这种女人就是神经病。只有当你的角色给读者和观众留下很深刻的印象的时候，这个角色的塑造才能算成功。前女友这个角色好像有什么大病，自从登场了以后就一直在阴阳怪气，排斥恋爱，但是她自己也是谈过恋爱的人，难道她是在否定自己吗？难道她之前和男主谈的恋爱就只是所谓的“玩玩而已”？她实际上就是个绿茶？她是不是绿茶我不知道，但是我能确定她是个合格的阴阳师，她一天到晚在那里冷嘲热讽让我不得不去怀疑她是不是有什么不好的过往，比如说被霸凌之类的，要不然她怎么会这么扭曲？说真的，我宁愿单身一辈子，也不想和这种腹黑来往，太可怕了，哪天我被捅死我都不觉得奇怪。</p><h2 id="男主对前女友的态度"><a href="#男主对前女友的态度" class="headerlink" title="男主对前女友的态度"></a>男主对前女友的态度</h2><p>我是真没见过有人在和女友分手以后还一天到晚意淫人家，然后偶然间见了面，还能抱着复合的态度和想法有说有笑。结合上面我对前女友的看法，我甚至无法理解男主在和她交往的那段时间里是怎么过的，每天和她在一起男主有什么想法。总之男主对前女友这样的态度以及他优柔寡断的样子让我非常厌恶。</p><h2 id="其他人"><a href="#其他人" class="headerlink" title="其他人"></a>其他人</h2><ul><li>这部剧里面唯一正常的人可能就是由 雨宮天 配音的 一之濑千鹤 小姐了。</li><li>除了 一之濑千鹤 小姐以外的那两位租借女友，不能说不正常，只能说不异常。</li><li>木部 作为主角的死党之一，其实也算正常人，只不过一直被主角租借女友的事情蒙在鼓里，变成蒙古人了。</li><li>栗林 作为主角的死党之一，相比 木部 来说，他在整部剧里的行为让他看起来就像个小丑，包括他跟男主一样，也会去使用租借女友的服务来满足虚荣心，只能说臭味相投、人以群分了。</li><li>奶奶这个角色就是典型的长辈形象，在剧中起到一点点推动剧情的作用，剩下的也就那样。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>剧情方面，有很多点我都懒得吐槽，包括穿着衣服海底救人这种超人般的行为。只能说这就是这一类番剧的特点了，看的时候千万不能带脑子，不然真的挺无聊的。从第七集开始男主给我的形象就非常差，到目前为止看来，男主全身上下除了编剧给硬套上去的日漫当中已经用烂了的极其老套的温柔属性以外，没有任何优点。优柔寡断、屌丝、不知足、知道自己有不足的地方但是又不愿意去努力改变、整天意淫、痴心妄想、纯纯一憨批，越看越让人觉得厌烦。</p><p>在看完最后一集的时候我还非常感动，为什么？因为男主到了最后一刻也没让我失望，他真的可以把无能贯彻到底，把屌丝发挥到极致。前面铺垫了那么多，到了最后最关键的时刻，竟然还是说不出最关键的话，我整个人都懵了！我甚至开始怀疑是作者真的想为了把故事写长一些所以让男主愣是把到了口中的话憋回去，还是只是单纯地在把观众当猴耍，如果是前者，那他那又没人家火影海贼死神写长篇的水平，如果是后者纯纯恶心人，那确实是跟谏山创一样可能有点精神问题。</p><p>这部番，无论是从恋爱、校园、喜剧哪一个角度来说，都是弟中弟。我看的番不多，在我看过的番剧中，校园恋爱，它不如春物，甚至可能不如冰菓，感觉还比伪恋差一点。喜剧，它又比不过银魂……反正我真的想不明白作者是以什么样的心态发表这样的作品。而且我隐约感觉到作者在刻画每个人物的时候，为了让每个人物的性格特点看起来更加不同或者更加突出，也不知道他是有意地还是无意地去让这些角色在他们那条人设线上越走越远，再结合作者自己的脑回路，就让这些角色在正常人眼中看起来显得特别的奇怪，就像是为了突出角色而突出角色。稍微反观一下春物，春物中的每个角色都有自己的特点，但是这个特点只会让这个角色看起来就像是那一类人的其中之一……</p><p>男主，上大学还兼职，长得也可以，为什么就是不敢表白？如果明知自己不足，为什么不去努力改变？整天只会搁那意淫，虚荣心还强，又自欺欺人……这样的人活该一辈子找不到女朋友。顺带一提，如果他拿他自己租借女友的钱去嫖，都不知道可以透多少个批了。</p><p>最后，这种看完第一季就已经用了我半条命甚至颠覆我三观的番剧，只有真正的抖M才会去看第二季，能坚持看完第一季只能说明我是强迫症，但是虐完一遍就够了。只有喜欢反复自虐的，才能算是真正的抖M。</p><p><img src="/../../images/ACGN/KanojoOkarishimasu12.jpg" alt="有租借女友这个钱我拿来干什么不好？"></p>]]></content>
    
    
    <categories>
      
      <category>ACGN</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>假面骑士 01 - Review</title>
    <link href="/posts/Review-Kamen-Rider-Zero-One/"/>
    <url>/posts/Review-Kamen-Rider-Zero-One/</url>
    
    <content type="html"><![CDATA[<p>被大家喷成屎的令和第一部假面骑士真的有这么烂吗？</p><span id="more"></span><p><img src="/../../images/ACGN/Kamen-Rider-Zero-One-review.jpg" alt="大结局中的一幕"></p><h2 id="演员"><a href="#演员" class="headerlink" title="演员"></a>演员</h2><p>无论是选角还是演员的演技，该剧的水平都不算差。就比如身为搞笑艺人讲的笑话却无法令人发笑、一身正气的、相信人类和仿生人终会和睦相处的年轻社长，以及始终相信着、辅佐着社长的超高颜值超可爱的社长秘书……这些都是让人印象深刻的角色。</p><h2 id="剧情"><a href="#剧情" class="headerlink" title="剧情"></a>剧情</h2><p>整部剧从第一集就表明了，当或人拿起 01 驱动器时，就说出了“梦想不是检索一下就能明白的随随便便的东西”。自那时起我就知道，除了人工智能，01 还融入了梦想这一元素。然而这个词由于在剧中被过多地被提到以至于观众们把它当成梗来玩，尽管这无伤大雅。</p><p>01 的前几集都是在讲仿生人如何与人类相处，或人一行人又是怎样改变人们对仿生人的看法，其过程中充满了曲折，在多处都展现了仿生人买家与卖家或人浓厚的感情表达。</p><h3 id="仿生人-VS-ZAIA终端"><a href="#仿生人-VS-ZAIA终端" class="headerlink" title="仿生人 VS ZAIA终端"></a>仿生人 VS ZAIA终端</h3><p>有些人说 Hiden 和 ZAIA 展开的仿生人和 ZAIA 终端的比试那几集很拉跨，其实我觉得不然，恰恰是那几集，真的非常精彩。</p><p>第一场比试是关于插花的，飞电输了，我觉得这在情理之中。因为就算仿生人能够在短时间内通过学习来获得大量知识，但终究无法获得一些实战经验，尤其是对于艺术品，在仿生人没能完全“成为”人类之前，只有人类能够通过艺术品来表达丰富的感情。再加上评委也是人类，这就让对方——搭载 ZAIA 终端的插花大师有了很大的优势。</p><p>第二场比试是关于卖房子的，飞电又输了，但是尽管输了比赛，我觉得飞电赢了人心。在比试的最后，是仿生人了解到了富豪内心真正的需求，从而给他推荐了一套山间的小房子，用于让他与家人聚在一起。但就是因为这个小房子的价格太低，导致飞电最终的销售额不及 ZAIA ，从而输了比试。</p><p>第三场是关于法庭上的比试，这一场比试很有意思，一是因为如果这一场飞电输了，那五局三胜的比赛就不用再进行下去了，因为 ZAIA 已经三胜了。所以综合各种情况，从剧情上来说，这一场比试应该是飞电要赢。二是设定上，飞电负责为被告人辩护，而 ZAIA 则需要为被告人定下罪名。但是这一场比试从一开始，在表现手法上，官方就告诉了观众，这个被告人是无罪的。这就很有意思，首先要知道，假面骑士的受众群体中是有小孩子的，如果这场比试飞电输了，那这个被告人必定是被冤枉的，这就是一场冤案。这大概率就会在小朋友们的心中产生阴影，让他们觉得这个世界很灰暗，为什么明明是好人却会被当作坏人，正义不仅迟到了，而且压根就没来。所以综合以上两个原因，飞电胜得毫无悬念。</p><p>第四场是关于消防救援能力的比试，这场比试也很有意思，首先仿生人的本质是机器人，机器人不像人类一样需要呼吸，那么在极端环境下例如火灾现场等，理论上应该比人类要更有优势，所以这场比试理论上来说应该是飞电赢。当然最终结果确实是飞电赢了，只不过不是靠机器人的优势赢的，而是到了最后，仿生人通过向对手学习，知道了“人命关天，当消防员救人，不应该单纯地相信数据分析，不应该放弃一丝救援的机会”，利用自己的优势，贡献了自己，帮助对手把火场的最后一批人救了出来……是的，贡献了自己，帮助了对手……这场比试的评判标准就是哪一方救的人多哪一方就获胜，然而仿生人却贡献了自己，自己都没了还怎么救人了呢。所以以结果来说，最后应该是 ZAIA 获胜，但是因为 ZAIA 方的参赛选手被仿生人的行为所感动，将自己的胜利位置让给了仿生人了，所以获胜方又变成了飞电。</p><p>第五场则是政治方面的比试，通过政治宣讲来号召人们进行投票支持，以票数来决定胜负。这一场比试说实话没啥意思，感觉就是单纯地为了让飞电输而让飞电输，故而不想多做评价。</p><h3 id="拉跨迫于无奈"><a href="#拉跨迫于无奈" class="headerlink" title="拉跨迫于无奈"></a>拉跨迫于无奈</h3><p>飞电和ZAIA的比试不算拉跨，真正拉跨的只能说是伊兹这个角色连续两次送的人头。但是这两次送人头又是极大地推动了剧情的发展，所以我只好理解为这是剧组的无奈之举。</p><h2 id="皮套特效和音效"><a href="#皮套特效和音效" class="headerlink" title="皮套特效和音效"></a>皮套特效和音效</h2><p>01 的皮套做得真心炫酷，简约而不简单，此外音效方面也没有时王这么吵，同时加入了非常标准的美式英语作为每个形态描述的配音。当然，说了那么多，不如把钱掏出来来得实在：<img src="/../../images/ACGN/ThousanDriver.jpg" alt="Thousan Driver"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>作为令和第一假面骑士，01 的表现并没有让我很失望，如果满分十分，我给这部剧七分。至于它的接档假面骑士 Saber ，单纯从皮套设计来说，我真的不是很喜欢。</p>]]></content>
    
    
    <categories>
      
      <category>ACGN</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>正当吐槽</title>
    <link href="/posts/Review-Just-Cause-2/"/>
    <url>/posts/Review-Just-Cause-2/</url>
    
    <content type="html"><![CDATA[<p>历时 20 个小时，终于把《正当防卫 2》的主线推完了。尽管它只花了我 4 块钱，但是我仍然有话要说。</p><span id="more"></span><h2 id="玩法"><a href="#玩法" class="headerlink" title="玩法"></a>玩法</h2><p>这是一个沙盘类型的游戏，其玩法很简单，如果想要开启新任务推动剧情发展，就一直“炸炸炸”就好了。但就是因为简单，这些重复的工作可能会让玩家觉得无聊，而我个人觉得还好，至少炸炸炸看着分数增长能让我有满足感。</p><h2 id="画质"><a href="#画质" class="headerlink" title="画质"></a>画质</h2><p>2020 年玩这款游戏，不应该去奢求画面，而应该去欣赏、品味它，因为这就是那个年代的味道。</p><h2 id="剧情"><a href="#剧情" class="headerlink" title="剧情"></a>剧情</h2><p>游戏的流程不算长，游戏的最后由 Rico 终结了独裁者的统治来收尾，Panau 小岛也迎来了一位亲美的总统，这样的结局不由得让人联想到现实……<img src="/../../images/ACGN/JustCause2Ending.jpg" alt="大结局中的一幕"></p><h2 id="不满意的地方"><a href="#不满意的地方" class="headerlink" title="不满意的地方"></a>不满意的地方</h2><ul><li>这游戏跟 GTA 一样也有通缉状态，想要逃离通缉也很简单，只需要脱离敌人的视线就行了，比如快速位移到另一个地方。但问题在于，被通缉也很简单，或者说很莫名其妙……有时候一进入敌人视野就会被通缉。试想一下，你在玩 GTA ，你刚上街遇到个警察，你明明什么都没做你就被通缉了——恶心至极的体验；顺带吐槽一下敌人的强度，一旦通缉等级高到一定程度，武装直升机就来了，这种情况下如果想用手头上的枪械解决直升机就需要找到一个很好的掩体才可以。为什么？因为 Rico 正面根本顶不住直升机上搭载的加特林！我的建议是站在原地被扫死然后重新开。此外，我在游玩的过程中安装了爪钩的 MOD ，其功能为突破原来爪钩的限制，可以一次位移至一公里以外甚至更远的位置。我利用了这个 MOD 来脱离敌人的视线，以此来达到逃避通缉的目的。然而当我到达新的地点的时候，直升机却是一下子就追了上来，我一度怀疑这是 BUG ……</li><li>爪钩的体验大部分时候很差。游戏过程中，除了上街抢载具、叫空投（最好别想了，没那么多钱）、搭“顺风车”这三种方式以外，想要快速移动就只能靠爪钩，但是爪钩钩中目标的判定有时候很迷，因为它有时候能钩到很远的目标，有时候明明很近的地方它又不让钩。</li><li>从高中落下俯冲的体验真的像坨屎，下落的时候感觉就像是我趴在床上滚一样，根本没法好好控制。</li><li>偶尔闪退。</li><li>没有中文。</li><li>重复的工作太多，建议打 MOD 节省时间和精力，安装一些合理的 MOD 可以在提升游玩的快感的同时不会因为过于逆天而破坏了游戏体验。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果不是盗版补票的话其实可以不用买了，尽管只卖 4 块钱。虽然我没玩过 3 代和 4 代，但个人感觉从这两者入坑或许好一点，不过如果想体验 2 代的剧情的话，那又只能买了。</p>]]></content>
    
    
    <categories>
      
      <category>ACGN</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>记一次刷机历程</title>
    <link href="/posts/To-flash-Lineage-OS-on-my-OnePlus-phone/"/>
    <url>/posts/To-flash-Lineage-OS-on-my-OnePlus-phone/</url>
    
    <content type="html"><![CDATA[<p>2020 年 2 月 27 日，我成功地将 Lineage OS 16 刷入我的 OnePlus 6 中。</p><span id="more"></span><h2 id="万事开头难"><a href="#万事开头难" class="headerlink" title="万事开头难"></a>万事开头难</h2><p>25 号的晚上至 26 号的凌晨，我尝试通过参照 Lineage OS 官网的 Wiki 来将 ROM 刷入我的一加 6 中，结果失败了。虽然我早就做好了心理准备，但是没想到我连 TWRP 都进不去。后面才了解到，一加 6 采用了前所未有的 A&#x2F;B 分区结构，这使得相对其他非 A&#x2F;B 分区结构的手机，一加 6 刷机的难度更大，操作更加复杂。</p><p>我一开始是参照 Wiki 刷入 TWRP 的，逐一执行命令：<code>fastboot set_active a</code>和<code>fastboot flash boot_a &lt;recovery_filename&gt;.img</code>，然后重启至 recovery 的时候手机就卡住了。当时心里想着如果要出什么问题的话怎么也得等到刷入 ROM 重启至系统的时候再出吧，结果刚起跑就摔倒了。随后也都有尝试单独执行<code>fastboot set_active b</code>和<code>fastboot flash boot_b &lt;recovery_filename&gt;.img</code>以及 a 和 b 一起刷的，但是都没用，这期间也在持续百度和 Google ，全都无果。最后狼狈地跑到 Reddit 发帖求助，一直到凌晨 3 点钟才上床睡觉，闭上眼睛的同时感到非常无助和绝望。</p><h2 id="中间难"><a href="#中间难" class="headerlink" title="中间难"></a>中间难</h2><p>早上起来，看到在 Reddit 发的贴子有人回复了，其大致意思就是：「就算是一加 6 最新的 TWRP ，亦都有可能无法运行在 Android 10 上。」这么说来，尽管昨晚折腾了很久，但很有可能就是在瞎折腾。热心网友还向我推荐了 XDA 的一个大佬，说是他有合适的 TWRP 。看到这里着实是感到了一丝希望，也有了大致的前进方向。</p><p>晚上来到 XDA 后利用我<del>的聪明才智和</del>这么多年来对电脑的操作经验，我很快找到了这个作者以及他发布 TWRP 的帖子，事不宜迟立刻下载尝试。经过一天的阅览和学习，我意识到了其实还可以直接使用<code>fastboot flash boot &lt;recovery_filename&gt;.img</code>和<code>fastboot boot &lt;recovery_filename&gt;.img</code>这两条命令而不再加上 a 或 b 分区来重启至 recovery ，不过这貌似也不是什么重点……</p><p>在我执行命令并重启至 recovery 的过程中，一切都和昨晚没什么区别。然而这一次，手机在重启到了带有黄色感叹号的界面后，在我紧张焦虑地注视下，TWRP 的 logo 出现了！这也意味着我成功地进入了 TWRP 。在一阵狂喜后，我接着参照 Wiki 的指示对数据进行格式化：Format Data 和擦除 System 分区的数据，然后就到最关键的一步——利用 Sideload 来安装系统包，结果不出意外地又出意外了。当我执行<code>adb sideload filename.zip</code>命令后，电脑上的命令提示符显示了一个百分比，然而当它跑到 47% 左右的时候，Sideload 就自动关闭了，随后命令提示符就会显示：</p><blockquote><p>Total Xfer 1.00x</p></blockquote><p>我不知道这是什么意思，我只知道这应该不是成功的意思。</p><p>在反复尝试了多次依旧无果后，我就又开始到处去寻找解决方案。最后是在 Wiki 中的一个对如何安装 GApps 的进行说明的文档页面里找到了答案：安装 GApps ，需要通过<code>adb push filename.zip /sdcard/</code>这条命令先将 GApps 的包传输到 SD 卡里，然后再进入 TWRP 的安装界面选择其进行安装。尽管这个页面描述的是 GApps 的安装方法，尽管我不知道这条命令跟 Sideload 有什么区别，但我感觉相同的操作放在安装系统 ROM 上是一样的……</p><p>果然，我的直觉是对的，前面提到的方法真的可以将 ROM 包刷入。并且这次是 TWRP 显示成功的，不是我说的。成功了自然是要重启手机，结果不出意外地又出意外了。手机在重启过程中，先是出现 Android 的 logo ，然后是一个带有黄色感叹号的界面，紧接着手机就黑屏了，到这里我人都傻了，黑屏以后又自动重启到 Fastboot Mode 。这是一个循环，无论开关机多少次都是这样。没办法了，去 Reddit 报喜的同时还得报忧……</p><h2 id="结尾难"><a href="#结尾难" class="headerlink" title="结尾难"></a>结尾难</h2><p>又是凌晨两点才睡，早上九点才醒，醒了第一件事就是去 Reddit 看看有没有高人为我指一条路——然而这一次却没人回复我了，心里想着看来还得靠自己去找答案了。</p><p>午饭过后通过 Google 找到一篇文章，主要内容就是教你怎么给 OnePlus 6 安装 Lineage OS 16 ，写得非常详细，还配有图片，每一步不仅告诉你该怎么做，还会给你解释为什么这么做……看来天无绝人之路，好戏才刚刚开始。</p><p>在用我的工地英语把文章整体看过一遍以后就准备动手照做了。不过请允许我再解释一下：在此之前，关于为什么手机开机不进系统而只会进到 Fastboot Mode 我其实已经大概有个头绪了。简单来说，很有可能就是系统缺斤少两了，比如该打的驱动没打上之类的。在后续阅读文章的过程中，我也注意到作者提到了一点：「Lineage OS 虽然自称是个 OS ，然而它并不具备一个完整的操作系统该有的模块。」这个结论在我在一加官网把氢 OS 的包下载下来并把它和 Lineage OS 的包的体积进行对比后得到了验证：氢OS 9.0.7 全量包的大小有将近两个 GB ，而<code>lineage-16.0-20200223-nightly-enchilada-signed.zip</code>的大小只有 486 MB。所以在参照文章指导的情况下，我现在要做的第一件事就是去一加的官网下载当时发布的 Android P 的最后稳定版本，并用它来作底包，然后再刷入 Lineage OS 。只有这样，系统才不会缺少必要的模块，才能正常开机运行。</p><p>在阅读文章的过程中我还了解到，对于 A&#x2F;B 分区的设备来说，一个包在安装时并不会被安装到当前所在的槽。也就是说，如果现在处在 A 槽，那么这个包将被安装到 B 槽中，这和大多数操作的效果是相反的。例如，在执行擦除 System 分区数据的操作时，受影响的就是当前槽的 System 分区，而另外一个槽是不受影响的。这个设定让我大开眼界，作者的说明让我茅塞顿开。按照文章的指导，接下来，当在我刷入底包以后，我需要做的就是切换至另一个槽，即底包所在的槽，对其执行擦除 System 分区的操作。这样一来，底包中的驱动等必要文件会得到保留，而单独把系统抹掉，又可以让我在后续刷入新的系统，这一切就说得通了。随后，我再按照类似的操作，把另一个槽也刷上底包并清除 System 分区，最后再把 Lineage OS 的 ROM 包分别刷入两个槽即可。</p><p>刷入 Lineage OS 以后，还要同时刷入 TWRP ，这是一个强大的 recovery ，此时刷入，将使其在手机的两槽上永久可用，同时在重启时，TWRP 还会隐式地为我们交换槽。最后如若有需要，可以再次重启至 TWRP ，进行 GApps 刷入以及对手机进行 Root 。</p><p>在进行完所有的工作以后就可以重启至系统了，最终，功夫不负有心人，我成功看到了 Lineage OS 的开机动画，直接原地起飞好吧。</p><h2 id="收尾"><a href="#收尾" class="headerlink" title="收尾"></a>收尾</h2><p>终于写到这里了。这次刷机，可以说是搞机生涯中的一个里程碑，因为我遇到并尝试去解决了很多问题。其实我完全可以不去折腾，氢OS 也用得好好的，我完全没必要吃饱没事干去把手机搞坏，而且就算我把手机整得不能正常开机了，我也完全可以把它返修，虽然过了保修期，不过我想他们帮我刷个系统无非就是点钱的事情，加上走顺丰快递，今天去明天回，也耽误不了太多时间。但是我并没有这么做，系统进不去了，但是 Fastboot Mode 还能进，我知道我还没有彻底失败。</p><p>其实我前段时间也有为一台 三星 Note 3 刷入 Lineage OS ，那是一台 2013 年的机器，而一加 6 是 2018 年的。这两者的区别就在于一加 6 是 A&#x2F;B 分区的机器，而 A&#x2F;B 分区说不定将会是未来安卓手机都会采用的技术，因为它从用户体验的角度来说真的很不错。我在一开始买回一加 6 进行 OTA 的时候就注意到了，它在下载完更新包后是可以直接安装的，安装过程在后台进行，安装期间你仍然可以去干别的事，例如回复 QQ 消息。在更新包安装完成后再重启手机就行了。而像我以前的手机，例如红米 1S ，当时更新系统是下载完更新包后就得关机更新了。</p><p>现如今我终于学会了如何给 A&#x2F;B 分区结构的机器刷机（无论将来是否能派上用场），但是如果我不去折腾，或者是折腾坏了就直接返修，那这就是另一个故事了。</p><p>我觉得无论是在什么行业做什么，都应该要带有一点折腾的精神。折腾，它一定会需要投入大量的时间和精力，并且不一定有所回报。但是如果没有折腾，或许就不会有进步。因为如果做一件事情毫不费力，那一定就是在浪费时间。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>假面骑士时王 - Review</title>
    <link href="/posts/Review-Kamen-Rider-Zio/"/>
    <url>/posts/Review-Kamen-Rider-Zio/</url>
    
    <content type="html"><![CDATA[<p>01 更新到 11 集的时候，我把时王补完了。</p><span id="more"></span><p><img src="/../../images/ACGN/Heiseikamenrider20.jpg" alt="平成系列第 20 部纪念作"></p><p>作为平成的最后一部假面骑士，我觉得还行，真的只是还行。本来我觉得作为一部有时代意义的作品（因为是平成结束的代表），你总得给人以震撼，但是没有，只不过也没有让人很失望就是了。</p><p>首先，以时间为主题讲述故事，我觉得挺难的，到底什么是过去，什么是未来？会陷入一种死循环，就好像超兽武装，我记得当初我看超兽武装的时候，狮王来到了现代，把异能锁还给了火麟飞，然后火麟飞在结局的时候又在古代把异能锁借给狮王，那到底是你先还给我我才借给你还是我先借给你你才还给我？时王同时还引入了平行世界的概念，也就是说，虽然我们都在地球上，我们都在日本，但是有我没有你，有你没有我。在 Decade 中，士他们要通过穿越来到下一位骑士的世界，但是在时王里又没有“穿越”这一说法，骑士们都是直接出现的，但是在时王结局，又谈到要毁灭世界就要把所有世界融合……做设定太难了。此外还有一个人人诟病的设定，那就是时王二阶，请问你已经有预知未来和时间倒流的能力了，你还有什么事做不了？</p><p>此外，变身音效太吵了、太杂了、太长了、花里胡哨的…这我也不喜欢。</p><p>除了以上的，其他的我觉得都做得很好：</p><ul><li>演员选得好，颜值够高，我还挺喜欢盖兹和月读那种稍微有点沙哑的声音。演技也够好，感情表达真的很到位！</li><li>前辈骑士的人间体也有大量回归，情怀加分。</li><li>幽默恶搞的戏份也是一如既往，令人开怀大笑。</li></ul><p>以上就是目前对时王整部剧的看法吧，有些东西还能继续说，但是懒得写了。01 见。</p><hr><p>这一次除了看剧，我还买了人生中的第一条腰带，也算是纪念平成的结束了<del>（上了东映的当 ）</del> 。XD<img src="/../../images/ACGN/ZikuDriver.jpg" alt="时空驱动器"></p>]]></content>
    
    
    <categories>
      
      <category>ACGN</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>《地铁：最后的曙光》通关感想</title>
    <link href="/posts/Review-Metro-Last-Light/"/>
    <url>/posts/Review-Metro-Last-Light/</url>
    
    <content type="html"><![CDATA[<p>前天晚上刚把《Metro: Last Light Redux》的主线推完。</p><span id="more"></span><p>作为《Metro 2033》的续作，不仅延续了前作的很多操作特色，还在其它方面做了优化、增加了细节。例如可以按<code>G</code>擦干净防毒面具上的雨水和血迹；除此之外，在战斗方面，击杀敌人的手感也得到了改善，不会出现说一个弹夹打完了都杀不死一个人的情况……除了新的武器之外还增加了武器定制的功能，我记得前作是没有的；最最重要的是，这一作增加了很多福利镜头，再加上游戏建模本身还算不错——这真的让人很社保。</p><p>游戏过程中该恐怖的地方还是有点恐怖的。不过相对前作来说感觉是差了一点，也有可能是玩多了变得不那么怕了吧……</p><p>剧情方面，本作的结尾不像前作那样那么魔幻，而是以阿尔乔姆的死来收尾……这就让我很期待续作的剧情。另外在游戏中小黑怪多次提到阿尔乔姆害死了他的家人和同类，最后在结局中它和剩余的黑怪离开了<img src="/../../images/ACGN/MetroLL1.jpg" alt="大结局中的一幕">，不知道这是不是为了给续作埋伏笔之类的。</p><p>总体来说算是我蛮喜欢的游戏了，以后有机会再把 2033 的 Redux 版玩一遍吧，之前玩的是 2010 年发行的 2033。到时候想试试另一个结局。<img src="/../../images/ACGN/MetroLL2.jpg" alt="大结局中的一幕"></p><p>最后附上乔伊做的一期对本游戏的剧情解说视频，做得挺好。<a href="https://www.bilibili.com/video/BV1R5411M7wT">核爆后的《地铁》究竟讲了什么样的故事？〖游戏不止〗</a></p>]]></content>
    
    
    <categories>
      
      <category>ACGN</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
